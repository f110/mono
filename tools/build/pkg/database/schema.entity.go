// Generated by protoc-ddl.
// protoc-gen-entity: v0.1
package database

import (
	"bytes"
	"sync"
	"time"

	"go.f110.dev/protoc-ddl"
)

var _ = time.Time{}
var _ = bytes.Buffer{}

type Column struct {
	Name  string
	Value interface{}
}

type SourceRepository struct {
	Id        int32
	Url       string
	CloneUrl  string
	Name      string
	Private   bool
	CreatedAt time.Time
	UpdatedAt *time.Time

	mu   sync.Mutex
	mark *SourceRepository
}

func (e *SourceRepository) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *SourceRepository) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Url != e.mark.Url ||
		e.CloneUrl != e.mark.CloneUrl ||
		e.Name != e.mark.Name ||
		e.Private != e.mark.Private ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *SourceRepository) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Url != e.mark.Url {
		res = append(res, ddl.Column{Name: "url", Value: e.Url})
	}
	if e.CloneUrl != e.mark.CloneUrl {
		res = append(res, ddl.Column{Name: "clone_url", Value: e.CloneUrl})
	}
	if e.Name != e.mark.Name {
		res = append(res, ddl.Column{Name: "name", Value: e.Name})
	}
	if e.Private != e.mark.Private {
		res = append(res, ddl.Column{Name: "private", Value: e.Private})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *SourceRepository) Copy() *SourceRepository {
	n := &SourceRepository{
		Id:        e.Id,
		Url:       e.Url,
		CloneUrl:  e.CloneUrl,
		Name:      e.Name,
		Private:   e.Private,
		CreatedAt: e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type Job struct {
	Id           int32
	Name         string
	RepositoryId int32
	Command      string
	Target       string
	Active       bool
	AllRevision  bool
	GithubStatus bool
	CpuLimit     string
	MemoryLimit  string
	Exclusive    bool
	Sync         bool
	ConfigName   string
	BazelVersion string
	JobType      string
	Schedule     string
	CreatedAt    time.Time
	UpdatedAt    *time.Time

	Repository *SourceRepository

	mu   sync.Mutex
	mark *Job
}

func (e *Job) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *Job) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Name != e.mark.Name ||
		e.RepositoryId != e.mark.RepositoryId ||
		e.Command != e.mark.Command ||
		e.Target != e.mark.Target ||
		e.Active != e.mark.Active ||
		e.AllRevision != e.mark.AllRevision ||
		e.GithubStatus != e.mark.GithubStatus ||
		e.CpuLimit != e.mark.CpuLimit ||
		e.MemoryLimit != e.mark.MemoryLimit ||
		e.Exclusive != e.mark.Exclusive ||
		e.Sync != e.mark.Sync ||
		e.ConfigName != e.mark.ConfigName ||
		e.BazelVersion != e.mark.BazelVersion ||
		e.JobType != e.mark.JobType ||
		e.Schedule != e.mark.Schedule ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *Job) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Name != e.mark.Name {
		res = append(res, ddl.Column{Name: "name", Value: e.Name})
	}
	if e.RepositoryId != e.mark.RepositoryId {
		res = append(res, ddl.Column{Name: "repository_id", Value: e.RepositoryId})
	}
	if e.Command != e.mark.Command {
		res = append(res, ddl.Column{Name: "command", Value: e.Command})
	}
	if e.Target != e.mark.Target {
		res = append(res, ddl.Column{Name: "target", Value: e.Target})
	}
	if e.Active != e.mark.Active {
		res = append(res, ddl.Column{Name: "active", Value: e.Active})
	}
	if e.AllRevision != e.mark.AllRevision {
		res = append(res, ddl.Column{Name: "all_revision", Value: e.AllRevision})
	}
	if e.GithubStatus != e.mark.GithubStatus {
		res = append(res, ddl.Column{Name: "github_status", Value: e.GithubStatus})
	}
	if e.CpuLimit != e.mark.CpuLimit {
		res = append(res, ddl.Column{Name: "cpu_limit", Value: e.CpuLimit})
	}
	if e.MemoryLimit != e.mark.MemoryLimit {
		res = append(res, ddl.Column{Name: "memory_limit", Value: e.MemoryLimit})
	}
	if e.Exclusive != e.mark.Exclusive {
		res = append(res, ddl.Column{Name: "exclusive", Value: e.Exclusive})
	}
	if e.Sync != e.mark.Sync {
		res = append(res, ddl.Column{Name: "sync", Value: e.Sync})
	}
	if e.ConfigName != e.mark.ConfigName {
		res = append(res, ddl.Column{Name: "config_name", Value: e.ConfigName})
	}
	if e.BazelVersion != e.mark.BazelVersion {
		res = append(res, ddl.Column{Name: "bazel_version", Value: e.BazelVersion})
	}
	if e.JobType != e.mark.JobType {
		res = append(res, ddl.Column{Name: "job_type", Value: e.JobType})
	}
	if e.Schedule != e.mark.Schedule {
		res = append(res, ddl.Column{Name: "schedule", Value: e.Schedule})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *Job) Copy() *Job {
	n := &Job{
		Id:           e.Id,
		Name:         e.Name,
		RepositoryId: e.RepositoryId,
		Command:      e.Command,
		Target:       e.Target,
		Active:       e.Active,
		AllRevision:  e.AllRevision,
		GithubStatus: e.GithubStatus,
		CpuLimit:     e.CpuLimit,
		MemoryLimit:  e.MemoryLimit,
		Exclusive:    e.Exclusive,
		Sync:         e.Sync,
		ConfigName:   e.ConfigName,
		BazelVersion: e.BazelVersion,
		JobType:      e.JobType,
		Schedule:     e.Schedule,
		CreatedAt:    e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	if e.Repository != nil {
		n.Repository = e.Repository.Copy()
	}

	return n
}

type Task struct {
	Id         int32
	JobId      int32
	Revision   string
	Success    bool
	LogFile    string
	Command    string
	Target     string
	Via        string
	ConfigName string
	StartAt    *time.Time
	FinishedAt *time.Time
	CreatedAt  time.Time
	UpdatedAt  *time.Time

	Job *Job

	mu   sync.Mutex
	mark *Task
}

func (e *Task) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *Task) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.JobId != e.mark.JobId ||
		e.Revision != e.mark.Revision ||
		e.Success != e.mark.Success ||
		e.LogFile != e.mark.LogFile ||
		e.Command != e.mark.Command ||
		e.Target != e.mark.Target ||
		e.Via != e.mark.Via ||
		e.ConfigName != e.mark.ConfigName ||
		((e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil)) ||
		((e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil)) ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *Task) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.JobId != e.mark.JobId {
		res = append(res, ddl.Column{Name: "job_id", Value: e.JobId})
	}
	if e.Revision != e.mark.Revision {
		res = append(res, ddl.Column{Name: "revision", Value: e.Revision})
	}
	if e.Success != e.mark.Success {
		res = append(res, ddl.Column{Name: "success", Value: e.Success})
	}
	if e.LogFile != e.mark.LogFile {
		res = append(res, ddl.Column{Name: "log_file", Value: e.LogFile})
	}
	if e.Command != e.mark.Command {
		res = append(res, ddl.Column{Name: "command", Value: e.Command})
	}
	if e.Target != e.mark.Target {
		res = append(res, ddl.Column{Name: "target", Value: e.Target})
	}
	if e.Via != e.mark.Via {
		res = append(res, ddl.Column{Name: "via", Value: e.Via})
	}
	if e.ConfigName != e.mark.ConfigName {
		res = append(res, ddl.Column{Name: "config_name", Value: e.ConfigName})
	}
	if (e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil) {
		if e.StartAt != nil {
			res = append(res, ddl.Column{Name: "start_at", Value: *e.StartAt})
		} else {
			res = append(res, ddl.Column{Name: "start_at", Value: nil})
		}
	}
	if (e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil) {
		if e.FinishedAt != nil {
			res = append(res, ddl.Column{Name: "finished_at", Value: *e.FinishedAt})
		} else {
			res = append(res, ddl.Column{Name: "finished_at", Value: nil})
		}
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *Task) Copy() *Task {
	n := &Task{
		Id:         e.Id,
		JobId:      e.JobId,
		Revision:   e.Revision,
		Success:    e.Success,
		LogFile:    e.LogFile,
		Command:    e.Command,
		Target:     e.Target,
		Via:        e.Via,
		ConfigName: e.ConfigName,
		CreatedAt:  e.CreatedAt,
	}
	if e.StartAt != nil {
		v := *e.StartAt
		n.StartAt = &v
	}
	if e.FinishedAt != nil {
		v := *e.FinishedAt
		n.FinishedAt = &v
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	if e.Job != nil {
		n.Job = e.Job.Copy()
	}

	return n
}

type TrustedUser struct {
	Id        int32
	GithubId  int64
	Username  string
	CreatedAt time.Time
	UpdatedAt *time.Time

	mu   sync.Mutex
	mark *TrustedUser
}

func (e *TrustedUser) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *TrustedUser) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.GithubId != e.mark.GithubId ||
		e.Username != e.mark.Username ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *TrustedUser) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.GithubId != e.mark.GithubId {
		res = append(res, ddl.Column{Name: "github_id", Value: e.GithubId})
	}
	if e.Username != e.mark.Username {
		res = append(res, ddl.Column{Name: "username", Value: e.Username})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *TrustedUser) Copy() *TrustedUser {
	n := &TrustedUser{
		Id:        e.Id,
		GithubId:  e.GithubId,
		Username:  e.Username,
		CreatedAt: e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type PermitPullRequest struct {
	Id         int32
	Repository string
	Number     int32
	CreatedAt  time.Time
	UpdatedAt  *time.Time

	mu   sync.Mutex
	mark *PermitPullRequest
}

func (e *PermitPullRequest) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *PermitPullRequest) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Repository != e.mark.Repository ||
		e.Number != e.mark.Number ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *PermitPullRequest) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Repository != e.mark.Repository {
		res = append(res, ddl.Column{Name: "repository", Value: e.Repository})
	}
	if e.Number != e.mark.Number {
		res = append(res, ddl.Column{Name: "number", Value: e.Number})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *PermitPullRequest) Copy() *PermitPullRequest {
	n := &PermitPullRequest{
		Id:         e.Id,
		Repository: e.Repository,
		Number:     e.Number,
		CreatedAt:  e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}
