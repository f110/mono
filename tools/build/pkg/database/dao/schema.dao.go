// Generated by protoc-ddl.
// protoc-gen-dao: v0.1
package dao

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"golang.org/x/xerrors"

	"go.f110.dev/mono/tools/build/pkg/database"
)

type SourceRepository struct {
	conn *sql.DB
}

func NewSourceRepository(conn *sql.DB) *SourceRepository {
	return &SourceRepository{
		conn: conn,
	}
}

func (d *SourceRepository) Select(ctx context.Context, id int32) (*database.SourceRepository, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `source_repository` WHERE `id` = ?", id)

	v := &database.SourceRepository{}
	if err := row.Scan(&v.Id, &v.Url, &v.CloneUrl, &v.Name, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *SourceRepository) ListAll(ctx context.Context) ([]*database.SourceRepository, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `source_repository`",
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.SourceRepository, 0)
	for rows.Next() {
		r := &database.SourceRepository{}
		if err := rows.Scan(&r.Id, &r.Url, &r.CloneUrl, &r.Name, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *SourceRepository) ListByUrl(ctx context.Context, url string) ([]*database.SourceRepository, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `source_repository` WHERE `url` = ?",
		url,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.SourceRepository, 0)
	for rows.Next() {
		r := &database.SourceRepository{}
		if err := rows.Scan(&r.Id, &r.Url, &r.CloneUrl, &r.Name, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *SourceRepository) Create(ctx context.Context, v *database.SourceRepository) (*database.SourceRepository, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`url`, `clone_url`, `name`, `created_at`) VALUES (?, ?, ?, ?)", v.Url, v.CloneUrl, v.Name, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *SourceRepository) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `source_repository` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *SourceRepository) Update(ctx context.Context, v *database.SourceRepository) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `source_repository` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type Job struct {
	conn *sql.DB

	sourceRepository *SourceRepository
}

func NewJob(conn *sql.DB) *Job {
	return &Job{
		conn:             conn,
		sourceRepository: NewSourceRepository(conn),
	}
}

func (d *Job) Select(ctx context.Context, id int32) (*database.Job, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `job` WHERE `id` = ?", id)

	v := &database.Job{}
	if err := row.Scan(&v.Id, &v.RepositoryId, &v.Command, &v.Target, &v.Active, &v.AllRevision, &v.GithubStatus, &v.CpuLimit, &v.MemoryLimit, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Repository = rel
	}

	v.ResetMark()
	return v, nil
}

func (d *Job) ListAll(ctx context.Context) ([]*database.Job, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `job`",
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Job, 0)
	for rows.Next() {
		r := &database.Job{}
		if err := rows.Scan(&r.Id, &r.RepositoryId, &r.Command, &r.Target, &r.Active, &r.AllRevision, &r.GithubStatus, &r.CpuLimit, &r.MemoryLimit, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Repository = rel
			}
		}
	}

	return res, nil
}

func (d *Job) ListBySourceRepositoryId(ctx context.Context, repositoryId int32) ([]*database.Job, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `job` WHERE `repository_id` = ?",
		repositoryId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Job, 0)
	for rows.Next() {
		r := &database.Job{}
		if err := rows.Scan(&r.Id, &r.RepositoryId, &r.Command, &r.Target, &r.Active, &r.AllRevision, &r.GithubStatus, &r.CpuLimit, &r.MemoryLimit, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Repository = rel
			}
		}
	}

	return res, nil
}

func (d *Job) Create(ctx context.Context, v *database.Job) (*database.Job, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`repository_id`, `command`, `target`, `active`, `all_revision`, `github_status`, `cpu_limit`, `memory_limit`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", v.RepositoryId, v.Command, v.Target, v.Active, v.AllRevision, v.GithubStatus, v.CpuLimit, v.MemoryLimit, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *Job) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `job` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Job) Update(ctx context.Context, v *database.Job) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `job` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type Task struct {
	conn *sql.DB

	job *Job
}

func NewTask(conn *sql.DB) *Task {
	return &Task{
		conn: conn,
		job:  NewJob(conn),
	}
}

func (d *Task) Select(ctx context.Context, id int32) (*database.Task, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `task` WHERE `id` = ?", id)

	v := &database.Task{}
	if err := row.Scan(&v.Id, &v.JobId, &v.Revision, &v.Success, &v.LogFile, &v.Command, &v.Target, &v.Via, &v.FinishedAt, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.job.Select(ctx, v.JobId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Job = rel
	}

	v.ResetMark()
	return v, nil
}

func (d *Task) ListByJobId(ctx context.Context, jobId int32) ([]*database.Task, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `task` WHERE `job_id` = ?",
		jobId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Task, 0)
	for rows.Next() {
		r := &database.Task{}
		if err := rows.Scan(&r.Id, &r.JobId, &r.Revision, &r.Success, &r.LogFile, &r.Command, &r.Target, &r.Via, &r.FinishedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.job.Select(ctx, v.JobId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Job = rel
			}
		}
	}

	return res, nil
}

func (d *Task) Create(ctx context.Context, v *database.Task) (*database.Task, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`job_id`, `revision`, `success`, `log_file`, `command`, `target`, `via`, `finished_at`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)", v.JobId, v.Revision, v.Success, v.LogFile, v.Command, v.Target, v.Via, v.FinishedAt, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *Task) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `task` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Task) Update(ctx context.Context, v *database.Task) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `task` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type TrustedUser struct {
	conn *sql.DB
}

func NewTrustedUser(conn *sql.DB) *TrustedUser {
	return &TrustedUser{
		conn: conn,
	}
}

func (d *TrustedUser) Select(ctx context.Context, id int32) (*database.TrustedUser, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `trusted_user` WHERE `id` = ?", id)

	v := &database.TrustedUser{}
	if err := row.Scan(&v.Id, &v.GithubId, &v.Username, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *TrustedUser) ListAll(ctx context.Context) ([]*database.TrustedUser, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `trusted_user`",
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.TrustedUser, 0)
	for rows.Next() {
		r := &database.TrustedUser{}
		if err := rows.Scan(&r.Id, &r.GithubId, &r.Username, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *TrustedUser) ListByGithubId(ctx context.Context, githubId int64) ([]*database.TrustedUser, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `trusted_user` WHERE `github_id` = ?",
		githubId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.TrustedUser, 0)
	for rows.Next() {
		r := &database.TrustedUser{}
		if err := rows.Scan(&r.Id, &r.GithubId, &r.Username, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *TrustedUser) Create(ctx context.Context, v *database.TrustedUser) (*database.TrustedUser, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`github_id`, `username`, `created_at`) VALUES (?, ?, ?)", v.GithubId, v.Username, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *TrustedUser) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `trusted_user` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *TrustedUser) Update(ctx context.Context, v *database.TrustedUser) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `trusted_user` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type PermitPullRequest struct {
	conn *sql.DB
}

func NewPermitPullRequest(conn *sql.DB) *PermitPullRequest {
	return &PermitPullRequest{
		conn: conn,
	}
}

func (d *PermitPullRequest) Select(ctx context.Context, id int32) (*database.PermitPullRequest, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `permit_pull_request` WHERE `id` = ?", id)

	v := &database.PermitPullRequest{}
	if err := row.Scan(&v.Id, &v.Repository, &v.Number, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *PermitPullRequest) ListByRepositoryAndNumber(ctx context.Context, repository string, number int32) ([]*database.PermitPullRequest, error) {
	rows, err := d.conn.QueryContext(
		ctx,
		"SELECT * FROM `permit_pull_request` WHERE `repository` = ? AND `number` = ?",
		repository,
		number,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.PermitPullRequest, 0)
	for rows.Next() {
		r := &database.PermitPullRequest{}
		if err := rows.Scan(&r.Id, &r.Repository, &r.Number, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *PermitPullRequest) Create(ctx context.Context, v *database.PermitPullRequest) (*database.PermitPullRequest, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`repository`, `number`, `created_at`) VALUES (?, ?, ?)", v.Repository, v.Number, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *PermitPullRequest) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `permit_pull_request` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *PermitPullRequest) Update(ctx context.Context, v *database.PermitPullRequest) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `permit_pull_request` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}
