// Generated by protoc-ddl.
// protoc-gen-dao: v0.1
package dao

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"golang.org/x/xerrors"

	"go.f110.dev/mono/tools/build/pkg/database"
)

type ListOption func(opt *listOpt)

func Limit(limit int) func(opt *listOpt) {
	return func(opt *listOpt) {
		opt.limit = limit
	}
}

func Desc(opt *listOpt) {
	opt.desc = true
}

type listOpt struct {
	limit int
	desc  bool
}

func newListOpt(opts ...ListOption) *listOpt {
	opt := &listOpt{}
	for _, v := range opts {
		v(opt)
	}
	return opt
}

type SourceRepository struct {
	conn *sql.DB
}

func NewSourceRepository(conn *sql.DB) *SourceRepository {
	return &SourceRepository{
		conn: conn,
	}
}

func (d *SourceRepository) Select(ctx context.Context, id int32) (*database.SourceRepository, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `source_repository` WHERE `id` = ?", id)

	v := &database.SourceRepository{}
	if err := row.Scan(&v.Id, &v.Url, &v.CloneUrl, &v.Name, &v.Private, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *SourceRepository) ListAll(ctx context.Context, opt ...ListOption) ([]*database.SourceRepository, error) {
	listOpts := newListOpt(opt...)
	query := "select id, url, clone_url, name, private, created_at, updated_at from source_repository"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.SourceRepository, 0)
	for rows.Next() {
		r := &database.SourceRepository{}
		if err := rows.Scan(&r.Id, &r.Url, &r.CloneUrl, &r.Name, &r.Private, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *SourceRepository) ListByUrl(ctx context.Context, url string, opt ...ListOption) ([]*database.SourceRepository, error) {
	listOpts := newListOpt(opt...)
	query := "select id, url, clone_url, name, private, created_at, updated_at from source_repository where url = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		url,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.SourceRepository, 0)
	for rows.Next() {
		r := &database.SourceRepository{}
		if err := rows.Scan(&r.Id, &r.Url, &r.CloneUrl, &r.Name, &r.Private, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *SourceRepository) Create(ctx context.Context, v *database.SourceRepository) (*database.SourceRepository, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `source_repository` (`url`, `clone_url`, `name`, `private`, `created_at`) VALUES (?, ?, ?, ?, ?)", v.Url, v.CloneUrl, v.Name, v.Private, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *SourceRepository) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `source_repository` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *SourceRepository) Update(ctx context.Context, v *database.SourceRepository) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `source_repository` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type Job struct {
	conn *sql.DB

	sourceRepository *SourceRepository
}

func NewJob(conn *sql.DB) *Job {
	return &Job{
		conn:             conn,
		sourceRepository: NewSourceRepository(conn),
	}
}

func (d *Job) Select(ctx context.Context, id int32) (*database.Job, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `job` WHERE `id` = ?", id)

	v := &database.Job{}
	if err := row.Scan(&v.Id, &v.RepositoryId, &v.Command, &v.Target, &v.Active, &v.AllRevision, &v.GithubStatus, &v.CpuLimit, &v.MemoryLimit, &v.Exclusive, &v.Sync, &v.ConfigName, &v.BazelVersion, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Repository = rel
	}

	v.ResetMark()
	return v, nil
}

func (d *Job) ListAll(ctx context.Context, opt ...ListOption) ([]*database.Job, error) {
	listOpts := newListOpt(opt...)
	query := "select id, repository_id, command, target, active, all_revision, github_status, cpu_limit, memory_limit, exclusive, sync, config_name, bazel_version, created_at, updated_at from job"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Job, 0)
	for rows.Next() {
		r := &database.Job{}
		if err := rows.Scan(&r.Id, &r.RepositoryId, &r.Command, &r.Target, &r.Active, &r.AllRevision, &r.GithubStatus, &r.CpuLimit, &r.MemoryLimit, &r.Exclusive, &r.Sync, &r.ConfigName, &r.BazelVersion, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Repository = rel
			}
		}
	}

	return res, nil
}

func (d *Job) ListBySourceRepositoryId(ctx context.Context, repositoryId int32, opt ...ListOption) ([]*database.Job, error) {
	listOpts := newListOpt(opt...)
	query := "select id, repository_id, command, target, active, all_revision, github_status, cpu_limit, memory_limit, exclusive, sync, config_name, bazel_version, created_at, updated_at from job where repository_id = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		repositoryId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Job, 0)
	for rows.Next() {
		r := &database.Job{}
		if err := rows.Scan(&r.Id, &r.RepositoryId, &r.Command, &r.Target, &r.Active, &r.AllRevision, &r.GithubStatus, &r.CpuLimit, &r.MemoryLimit, &r.Exclusive, &r.Sync, &r.ConfigName, &r.BazelVersion, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.sourceRepository.Select(ctx, v.RepositoryId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Repository = rel
			}
		}
	}

	return res, nil
}

func (d *Job) Create(ctx context.Context, v *database.Job) (*database.Job, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `job` (`repository_id`, `command`, `target`, `active`, `all_revision`, `github_status`, `cpu_limit`, `memory_limit`, `exclusive`, `sync`, `config_name`, `bazel_version`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", v.RepositoryId, v.Command, v.Target, v.Active, v.AllRevision, v.GithubStatus, v.CpuLimit, v.MemoryLimit, v.Exclusive, v.Sync, v.ConfigName, v.BazelVersion, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *Job) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `job` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Job) Update(ctx context.Context, v *database.Job) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `job` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type Task struct {
	conn *sql.DB

	job *Job
}

func NewTask(conn *sql.DB) *Task {
	return &Task{
		conn: conn,
		job:  NewJob(conn),
	}
}

func (d *Task) Select(ctx context.Context, id int32) (*database.Task, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `task` WHERE `id` = ?", id)

	v := &database.Task{}
	if err := row.Scan(&v.Id, &v.JobId, &v.Revision, &v.Success, &v.LogFile, &v.Command, &v.Target, &v.Via, &v.ConfigName, &v.StartAt, &v.FinishedAt, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	{
		rel, err := d.job.Select(ctx, v.JobId)
		if err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		v.Job = rel
	}

	v.ResetMark()
	return v, nil
}

func (d *Task) ListByJobId(ctx context.Context, jobId int32, opt ...ListOption) ([]*database.Task, error) {
	listOpts := newListOpt(opt...)
	query := "select id, job_id, revision, success, log_file, command, target, via, config_name, start_at, finished_at, created_at, updated_at from task where job_id = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		jobId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Task, 0)
	for rows.Next() {
		r := &database.Task{}
		if err := rows.Scan(&r.Id, &r.JobId, &r.Revision, &r.Success, &r.LogFile, &r.Command, &r.Target, &r.Via, &r.ConfigName, &r.StartAt, &r.FinishedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.job.Select(ctx, v.JobId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Job = rel
			}
		}
	}

	return res, nil
}

func (d *Task) ListPending(ctx context.Context, opt ...ListOption) ([]*database.Task, error) {
	listOpts := newListOpt(opt...)
	query := "select id, job_id, revision, success, log_file, command, target, via, config_name, start_at, finished_at, created_at, updated_at from task where start_at is null"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.Task, 0)
	for rows.Next() {
		r := &database.Task{}
		if err := rows.Scan(&r.Id, &r.JobId, &r.Revision, &r.Success, &r.LogFile, &r.Command, &r.Target, &r.Via, &r.ConfigName, &r.StartAt, &r.FinishedAt, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}
	if len(res) > 0 {
		for _, v := range res {
			{
				rel, err := d.job.Select(ctx, v.JobId)
				if err != nil {
					return nil, xerrors.Errorf(": %w", err)
				}
				v.Job = rel
			}
		}
	}

	return res, nil
}

func (d *Task) Create(ctx context.Context, v *database.Task) (*database.Task, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `task` (`job_id`, `revision`, `success`, `log_file`, `command`, `target`, `via`, `config_name`, `start_at`, `finished_at`, `created_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", v.JobId, v.Revision, v.Success, v.LogFile, v.Command, v.Target, v.Via, v.ConfigName, v.StartAt, v.FinishedAt, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *Task) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `task` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *Task) Update(ctx context.Context, v *database.Task) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `task` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type TrustedUser struct {
	conn *sql.DB
}

func NewTrustedUser(conn *sql.DB) *TrustedUser {
	return &TrustedUser{
		conn: conn,
	}
}

func (d *TrustedUser) Select(ctx context.Context, id int32) (*database.TrustedUser, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `trusted_user` WHERE `id` = ?", id)

	v := &database.TrustedUser{}
	if err := row.Scan(&v.Id, &v.GithubId, &v.Username, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *TrustedUser) ListAll(ctx context.Context, opt ...ListOption) ([]*database.TrustedUser, error) {
	listOpts := newListOpt(opt...)
	query := "select id, github_id, username, created_at, updated_at from trusted_user"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.TrustedUser, 0)
	for rows.Next() {
		r := &database.TrustedUser{}
		if err := rows.Scan(&r.Id, &r.GithubId, &r.Username, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *TrustedUser) ListByGithubId(ctx context.Context, githubId int64, opt ...ListOption) ([]*database.TrustedUser, error) {
	listOpts := newListOpt(opt...)
	query := "select id, github_id, username, created_at, updated_at from trusted_user where github_id = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		githubId,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.TrustedUser, 0)
	for rows.Next() {
		r := &database.TrustedUser{}
		if err := rows.Scan(&r.Id, &r.GithubId, &r.Username, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *TrustedUser) Create(ctx context.Context, v *database.TrustedUser) (*database.TrustedUser, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `trusted_user` (`github_id`, `username`, `created_at`) VALUES (?, ?, ?)", v.GithubId, v.Username, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *TrustedUser) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `trusted_user` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *TrustedUser) Update(ctx context.Context, v *database.TrustedUser) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `trusted_user` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}

type PermitPullRequest struct {
	conn *sql.DB
}

func NewPermitPullRequest(conn *sql.DB) *PermitPullRequest {
	return &PermitPullRequest{
		conn: conn,
	}
}

func (d *PermitPullRequest) Select(ctx context.Context, id int32) (*database.PermitPullRequest, error) {
	row := d.conn.QueryRowContext(ctx, "SELECT * FROM `permit_pull_request` WHERE `id` = ?", id)

	v := &database.PermitPullRequest{}
	if err := row.Scan(&v.Id, &v.Repository, &v.Number, &v.CreatedAt, &v.UpdatedAt); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	v.ResetMark()
	return v, nil
}

func (d *PermitPullRequest) ListByRepositoryAndNumber(ctx context.Context, repository string, number int32, opt ...ListOption) ([]*database.PermitPullRequest, error) {
	listOpts := newListOpt(opt...)
	query := "select id, repository, number, created_at, updated_at from permit_pull_request where repository = ? and number = ?"
	if listOpts.limit > 0 {
		order := "ASC"
		if listOpts.desc {
			order = "DESC"
		}
		query = query + fmt.Sprintf(" ORDER BY `id` %s LIMIT %d", order, listOpts.limit)
	}
	rows, err := d.conn.QueryContext(
		ctx,
		query,
		repository,
		number,
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	res := make([]*database.PermitPullRequest, 0)
	for rows.Next() {
		r := &database.PermitPullRequest{}
		if err := rows.Scan(&r.Id, &r.Repository, &r.Number, &r.CreatedAt, &r.UpdatedAt); err != nil {
			return nil, xerrors.Errorf(": %w", err)
		}
		r.ResetMark()
		res = append(res, r)
	}

	return res, nil
}

func (d *PermitPullRequest) Create(ctx context.Context, v *database.PermitPullRequest) (*database.PermitPullRequest, error) {
	res, err := d.conn.ExecContext(
		ctx,
		"INSERT INTO `permit_pull_request` (`repository`, `number`, `created_at`) VALUES (?, ?, ?)", v.Repository, v.Number, time.Now(),
	)
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return nil, xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return nil, sql.ErrNoRows
	}

	v = v.Copy()
	insertedId, err := res.LastInsertId()
	if err != nil {
		return nil, xerrors.Errorf(": %w", err)
	}
	v.Id = int32(insertedId)

	v.ResetMark()
	return v, nil
}

func (d *PermitPullRequest) Delete(ctx context.Context, id int32) error {
	res, err := d.conn.ExecContext(ctx, "DELETE FROM `permit_pull_request` WHERE `id` = ?", id)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}

	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (d *PermitPullRequest) Update(ctx context.Context, v *database.PermitPullRequest) error {
	if !v.IsChanged() {
		return nil
	}

	changedColumn := v.ChangedColumn()
	cols := make([]string, len(changedColumn)+1)
	values := make([]interface{}, len(changedColumn)+1)
	for i := range changedColumn {
		cols[i] = "`" + changedColumn[i].Name + "` = ?"
		values[i] = changedColumn[i].Value
	}
	cols[len(cols)-1] = "`updated_at` = ?"
	values[len(values)-1] = time.Now()

	query := fmt.Sprintf("UPDATE `permit_pull_request` SET %s WHERE `id` = ?", strings.Join(cols, ", "))
	res, err := d.conn.ExecContext(
		ctx,
		query,
		append(values, v.Id)...,
	)
	if err != nil {
		return xerrors.Errorf(": %w", err)
	}
	if n, err := res.RowsAffected(); err != nil {
		return xerrors.Errorf(": %w", err)
	} else if n == 0 {
		return sql.ErrNoRows
	}

	v.ResetMark()
	return nil
}
