package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"vitess.io/vitess/go/vt/sqlparser"

	"go.f110.dev/protoc-ddl/internal/schema"
)

const GoDAOGeneratorVersion = "v0.1"

type GoDAOGenerator struct{}

func (g GoDAOGenerator) Generate(buf *bytes.Buffer, fileOpt *descriptor.FileOptions, messages *schema.Messages) {
	src := newBuffer()

	entityPackageName := fileOpt.GetGoPackage()
	if strings.Contains(entityPackageName, ";") {
		s := strings.SplitN(entityPackageName, ";", 2)
		entityPackageName = s[0]
	}
	entityPackageAlias := filepath.Base(entityPackageName)

	src.WriteString("package dao\n")
	src.WriteString("import (\n")
	for _, v := range []string{"context", "database/sql", "fmt", "time", "strings"} {
		src.WriteString("\"" + v + "\"\n")
	}
	src.WriteRune('\n')
	for _, v := range []string{"golang.org/x/xerrors"} {
		src.WriteString("\"" + v + "\"\n")
	}
	src.WriteRune('\n')
	src.WriteString(fmt.Sprintf("\"%s\"\n", entityPackageName))
	src.WriteString(")\n")

	// ListOption
	src.WriteString(`
	type ListOption func(opt *listOpt)

	func Limit(limit int) func(opt *listOpt) {
		return func(opt *listOpt) {
			opt.limit = limit
		}
	}

    func Desc(opt *listOpt) {
        opt.desc = true
    }

	type listOpt struct {
		limit int
        desc  bool
	}

	func newListOpt(opts ...ListOption) *listOpt {
		opt := &listOpt{}
		for _, v := range opts {
			v(opt)
		}
		return opt
	}

	type ExecOption func(opt *execOpt)

	func WithTx(tx *sql.Tx) ExecOption {
		return func(opt *execOpt) {
			opt.tx = tx
		}
	}
	
	type execOpt struct {
		tx *sql.Tx
	}

	func newExecOpt(opts ...ExecOption) *execOpt {
		opt := &execOpt{}
		for _, v := range opts {
			v(opt)
		}
		return opt
	}

	type execConn interface {
		ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
	}

`)

	messages.Each(func(m *schema.Message) {
		rels := make(map[string]struct{})
		for f := range m.Relations {
			if f.Virtual {
				continue
			}
			s := strings.Split(f.Type, ".")
			rels[s[len(s)-1]] = struct{}{}
		}
		relations := make([]string, 0)
		for v := range rels {
			relations = append(relations, v)
		}
		sort.Strings(relations)

		src.WriteString(fmt.Sprintf("type %s struct {\nconn *sql.DB\n\n", m.Descriptor.GetName()))
		for _, r := range relations {
			src.WriteString(fmt.Sprintf("%s *%s\n", schema.ToLowerCamel(r), schema.ToCamel(r)))
		}
		src.WriteString("}\n")
		src.WriteRune('\n')
		src.WriteString(fmt.Sprintf("func New%s(conn *sql.DB) *%s {\n", m.Descriptor.GetName(), m.Descriptor.GetName()))
		src.WriteString(fmt.Sprintf("return &%s{\nconn: conn,\n", m.Descriptor.GetName()))
		for _, r := range relations {
			src.WriteString(fmt.Sprintf("%s: New%s(conn),\n", schema.ToLowerCamel(r), schema.ToCamel(r)))
		}
		src.WriteString("}\n")
		src.WriteString("}\n\n")

		src.WriteString(fmt.Sprintf("func (d *%s) Tx(ctx context.Context, fn func(tx *sql.Tx) error) error {\n", m.Descriptor.GetName()))
		src.WriteString(`tx, err := d.conn.BeginTx(ctx, nil)
			if err != nil {
			return xerrors.Errorf(": %w", err)
		}
			if err := fn(tx); err != nil {
			rErr := tx.Rollback()
			return xerrors.Errorf("%v: %w", rErr, err)
		}

			err = tx.Commit()
			if err != nil {
			return xerrors.Errorf(": %w", err)
		}
			return nil
		}`)
		src.WriteString("\n\n")

		s := &GoDAOStruct{m: m, entityPackageName: entityPackageAlias}
		f := s.PrimaryKeySelect(g.primaryKeySelect)
		src.WriteString(f.String())
		src.LineBreak()

		funcs := s.Select(g.selectRowQuery)
		for _, v := range funcs {
			src.WriteString(v.String())
			src.LineBreak()
		}

		f = s.Create(g.create)
		src.WriteString(f.String())
		src.LineBreak()

		f = s.Delete(g.delete)
		src.WriteString(f.String())
		src.LineBreak()

		f = s.Update(g.update)
		src.WriteString(f.String())
		src.LineBreak()
	})

	buf.WriteString("// Generated by protoc-ddl.\n")
	buf.WriteString(fmt.Sprintf("// protoc-gen-dao: %s\n", GoDAOGeneratorVersion))
	b, err := format.Source(src.Bytes())
	if err != nil {
		r := bufio.NewScanner(strings.NewReader(src.String()))
		line := 1
		for r.Scan() {
			fmt.Fprintf(os.Stderr, "%d: %s\n", line, r.Text())
			line++
		}
		log.Print(err)
		return
	}
	buf.Write(b)
}

func (g GoDAOGenerator) create(m *schema.Message, f *goFunc) string {
	src := newBuffer()

	valueArg := f.Args[1]
	src.Write(`execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}`)
	src.LineBreak()
	src.Write("res, err := conn.ExecContext(\nctx,")
	cols := make([]string, 0, m.Fields.Len())
	queryArgs := make([]string, 0, m.Fields.Len())
	m.Fields.Each(func(f *schema.Field) {
		if f.Sequence {
			return
		}
		if m.WithTimestamp && (f.Name == "created_at" || f.Name == "updated_at") {
			return
		}
		cols = append(cols, "`"+f.Name+"`")
		queryArgs = append(queryArgs, fmt.Sprintf("%s.%s", valueArg.Name, schema.ToCamel(f.Name)))
	})
	if m.WithTimestamp {
		cols = append(cols, "`created_at`")
		queryArgs = append(queryArgs, "time.Now()")
	}
	args := make([]string, len(cols))
	for i := 0; i < len(args); i++ {
		args[i] = "?"
	}

	src.Writef("\"INSERT INTO `%s` (%s) VALUES (%s)\",", m.TableName, strings.Join(cols, ", "), strings.Join(args, ", "))
	src.Write(strings.Join(queryArgs, ",") + ",")
	src.Write(")")
	src.Write("if err != nil {\nreturn nil, xerrors.Errorf(\": %w\", err)\n}")
	src.LineBreak()
	src.Write("if n, err := res.RowsAffected(); err != nil {")
	src.Write("return nil, xerrors.Errorf(\": %w\", err)")
	src.Write("} else if n == 0 {")
	src.Write("return nil, sql.ErrNoRows")
	src.Write("}")
	src.LineBreak()
	src.Writef("%s = %s.Copy()", valueArg.Name, valueArg.Name)
	if m.PrimaryKeys[0].Sequence {
		src.Write("insertedId, err := res.LastInsertId()")
		src.Write("if err != nil {")
		src.Write("return nil, xerrors.Errorf(\": %w\", err)")
		src.Write("}")
		src.Writef("%s.Id = %s(insertedId)", valueArg.Name, GoDataTypeMap[m.PrimaryKeys[0].Type])
	}
	src.LineBreak()

	src.Writef("%s.ResetMark()", valueArg.Name)
	src.Writef("return %s, nil", valueArg.Name)

	return src.String()
}

func (g GoDAOGenerator) delete(m *schema.Message, _ *goFunc, where, whereArgs []string) string {
	src := newBuffer()

	src.WriteString(`execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}`)
	src.WriteString("\n\n")
	src.WriteString(fmt.Sprintf("res, err := conn.ExecContext(ctx, \"DELETE FROM `%s` WHERE %s\", %s)\n", m.TableName, strings.Join(where, " AND "), strings.Join(whereArgs, ",")))
	src.WriteString("if err != nil {\n")
	src.WriteString("return xerrors.Errorf(\": %w\", err)\n")
	src.WriteString("}\n\n")
	src.WriteString("if n, err := res.RowsAffected(); err != nil {\n")
	src.WriteString("return xerrors.Errorf(\": %w\", err)\n")
	src.WriteString("} else if n == 0 {\n")
	src.WriteString("return sql.ErrNoRows\n")
	src.WriteString("}\n\n")
	src.WriteString("return nil\n")

	return src.String()
}

func (g GoDAOGenerator) update(m *schema.Message, f *goFunc) string {
	src := newBuffer()
	valueArgs := f.Args[1]

	src.Writef("if !%s.IsChanged() {", valueArgs.Name)
	src.Write("return nil")
	src.Write("}")
	src.LineBreak()

	src.Write(`execOpts := newExecOpt(opt...)
	var conn execConn
	if execOpts.tx != nil {
		conn = execOpts.tx
	} else {
		conn = d.conn
	}`)
	src.LineBreak()

	src.Writef("changedColumn := %s.ChangedColumn()", valueArgs.Name)
	src.Write("cols := make([]string, len(changedColumn)+1)")
	src.Write("values := make([]interface{}, len(changedColumn)+1)")
	src.Write("for i := range changedColumn {")
	src.Write("cols[i] = \"`\" + changedColumn[i].Name + \"` = ?\"")
	src.Write("values[i] = changedColumn[i].Value")
	src.Write("}")
	if m.WithTimestamp {
		src.Write("cols[len(cols)-1] = \"`updated_at` = ?\"")
		src.Write("values[len(values)-1] = time.Now()")
	}
	src.LineBreak()

	where := make([]string, 0)
	whereArgs := make([]string, 0)
	for _, v := range m.PrimaryKeys {
		where = append(where, fmt.Sprintf("`%s` = ?", v.Name))
		whereArgs = append(whereArgs, valueArgs.Name+"."+schema.ToCamel(v.Name))
	}
	src.Writef("query := fmt.Sprintf(\"UPDATE `%s` SET %%s WHERE %s\", strings.Join(cols, \", \"))", m.TableName, strings.Join(where, " AND "))
	src.Write("res, err := conn.ExecContext(")
	src.Write("ctx,")
	src.Write("query,")
	src.Writef("append(values, %s)...,", strings.Join(whereArgs, ","))
	src.Write(")")
	src.Write("if err != nil {")
	src.Write("return xerrors.Errorf(\": %w\", err)")
	src.Write("}")

	src.Write("if n, err := res.RowsAffected(); err != nil {")
	src.Write("return xerrors.Errorf(\": %w\", err)")
	src.Write("} else if n == 0 {")
	src.Write("return sql.ErrNoRows")
	src.Write("}")
	src.LineBreak()

	src.Writef("%s.ResetMark()", valueArgs.Name)
	src.Write("return nil")

	return src.String()
}

func (g GoDAOGenerator) primaryKeySelect(entityName string, m *schema.Message, _, where, whereArgs []string) string {
	src := newBuffer()
	src.Buffer.WriteString("row := d.conn.QueryRowContext(ctx,")
	src.Writef("\"SELECT * FROM `%s` WHERE %s\", %s)\n", m.TableName, strings.Join(where, " AND "), strings.Join(whereArgs, ","))
	src.LineBreak()
	src.Writef("v := &%s.%s{}", entityName, m.Descriptor.GetName())
	cols := make([]string, 0, m.Fields.Len())
	m.Fields.Each(func(f *schema.Field) {
		cols = append(cols, "&v."+schema.ToCamel(f.Name))
	})
	src.Writef("if err := row.Scan(%s); err != nil {", strings.Join(cols, ","))
	src.Write("return nil, xerrors.Errorf(\": %w\", err)\n}")
	src.LineBreak()

	g.selectChildObject(src, m)

	src.Write("v.ResetMark()")
	src.Write("return v, nil")

	return src.String()
}

func (g GoDAOGenerator) selectQuery(src *Buffer, m *schema.Message, name string, stmt *sqlparser.Select, entityName string) {
	if len(stmt.From) != 1 {
		log.Printf("Multiple tables is not supported")
		return
	}

	allColumn := false
	var cols []string
	for _, c := range stmt.SelectExprs {
		if _, ok := c.(*sqlparser.StarExpr); ok {
			allColumn = true
			cols = nil
			break
		}

		co, ok := c.(*sqlparser.AliasedExpr)
		if !ok {
			log.Printf("%v is %v", c, reflect.TypeOf(c))
			continue
		}
		col, ok := co.Expr.(*sqlparser.ColName)
		if !ok {
			log.Printf("%v is not ColName", c)
			continue
		}
		cols = append(cols, col.Name.String())
	}
	if allColumn {
		cols = make([]string, 0)
		stmt.SelectExprs = make([]sqlparser.SelectExpr, 0)
		for _, v := range m.Fields.List() {
			cols = append(cols, v.Name)
			stmt.SelectExprs = append(stmt.SelectExprs, &sqlparser.AliasedExpr{
				Expr: &sqlparser.ColName{
					Name: sqlparser.NewColIdent(v.Name),
				},
			})
		}
	}

	var comp []*schema.Field
	if stmt.Where != nil {
		comp = g.findArgs(m.Fields.List(), stmt.Where)
	}

	isReturningSingleRow := m.IsReturningSingleRow(comp...)
	args := make([]string, len(comp))
	for i := range comp {
		args[i] = fmt.Sprintf("%s %s", schema.ToLowerCamel(comp[i].Name), GoDataTypeMap[comp[i].Type])
	}
	if !isReturningSingleRow {
		args = append(args, "opt ...ListOption")
	}

	if isReturningSingleRow {
		g.selectSingleRowQuery(m, name, stmt, comp, args, entityName)
	} else {
		g.selectMultipleRowQuery(m, name, stmt, cols, comp, args, entityName)
	}
}

func (g GoDAOGenerator) selectRowQuery(m *schema.Message, name string, stmt *sqlparser.Select, comp []*schema.Field, cols, args []string, entityName string, single bool) string {
	if single {
		return g.selectSingleRowQuery(m, name, stmt, comp, args, entityName)
	} else {
		return g.selectMultipleRowQuery(m, name, stmt, cols, comp, args, entityName)
	}
}

func (g GoDAOGenerator) selectMultipleRowQuery(m *schema.Message, name string, stmt *sqlparser.Select, selectCols []string, comp []*schema.Field, args []string, entityName string) string {
	src := newBuffer()
	primaryKeys := make([]string, 0)
	for _, v := range m.PrimaryKeys {
		primaryKeys = append(primaryKeys, "`"+v.Name+"`")
	}
	src.WriteString("listOpts := newListOpt(opt...)\n")
	src.WriteString(fmt.Sprintf("query := %q\n", printSelectQueryAST(m, stmt)))
	src.WriteString("if listOpts.limit > 0 {\n")
	src.WriteString("order := \"ASC\"\n")
	src.WriteString("if listOpts.desc {\n")
	src.WriteString("order = \"DESC\"\n")
	src.WriteString("}\n")
	src.WriteString(fmt.Sprintf("query = query + fmt.Sprintf(\" ORDER BY %s %%s LIMIT %%d\",order, listOpts.limit)\n", strings.Join(primaryKeys, ", ")))
	src.WriteString("}\n")
	src.WriteString("rows, err := d.conn.QueryContext(\nctx,\nquery,\n")
	for _, a := range comp {
		src.WriteString(schema.ToLowerCamel(a.Name) + ",\n")
	}
	src.WriteString(")\n")
	src.WriteString("if err != nil {\nreturn nil, xerrors.Errorf(\": %w\", err)\n}\n")
	src.WriteRune('\n')

	// Object mapping
	src.WriteString(fmt.Sprintf("res := make([]*%s.%s, 0)\n", entityName, m.Descriptor.GetName()))
	src.WriteString("for rows.Next() {\n")
	src.WriteString(fmt.Sprintf("r := &%s.%s{}\n", entityName, m.Descriptor.GetName()))
	scanCols := make([]string, len(selectCols))
	for i, v := range selectCols {
		scanCols[i] = "&r." + schema.ToCamel(v)
	}
	src.WriteString(fmt.Sprintf("if err := rows.Scan(%s); err != nil {\n", strings.Join(scanCols, ",")))
	src.WriteString("return nil, xerrors.Errorf(\": %w\", err)\n")
	src.WriteString("}\n")
	src.WriteString("r.ResetMark()\n")
	src.WriteString("res = append(res, r)\n")
	src.WriteString("}\n")

	if len(m.Relations) > 0 {
		src.WriteString("if len(res) > 0 {\n")
		src.WriteString("for _, v := range res {\n")
		g.selectChildObject(src, m)
		src.WriteString("}\n")
		src.WriteString("}\n")
	}

	src.WriteRune('\n')
	src.WriteString("return res, nil\n")

	return src.String()
}

func (g GoDAOGenerator) selectSingleRowQuery(m *schema.Message, name string, stmt *sqlparser.Select, comp []*schema.Field, args []string, entityName string) string {
	src := newBuffer()

	primaryKeys := make([]string, 0)
	for _, v := range m.PrimaryKeys {
		primaryKeys = append(primaryKeys, "`"+v.Name+"`")
	}
	src.WriteString(fmt.Sprintf("row := d.conn.QueryRowContext(\nctx,\n%q,\n", printSelectQueryAST(m, stmt)))
	for _, a := range comp {
		src.WriteString(schema.ToLowerCamel(a.Name) + ",\n")
	}
	src.WriteString(")\n")

	src.WriteString(fmt.Sprintf("v := &%s.%s{}\n", entityName, m.Descriptor.GetName()))
	cols := make([]string, 0, m.Fields.Len())
	m.Fields.Each(func(f *schema.Field) {
		cols = append(cols, "&v."+schema.ToCamel(f.Name))
	})
	src.WriteString(fmt.Sprintf("if err := row.Scan(%s); err != nil {\n", strings.Join(cols, ",")))
	src.WriteString("return nil, xerrors.Errorf(\": %w\", err)\n}\n\n")

	g.selectChildObject(src, m)

	src.WriteString("v.ResetMark()\n")
	src.WriteString("return v, nil\n")

	return src.String()

}

func (g GoDAOGenerator) selectChildObject(src *Buffer, m *schema.Message) {
	if len(m.Relations) == 0 {
		return
	}

	relFields := make([]*schema.Field, 0)
	for f := range m.Relations {
		if f.Virtual {
			continue
		}
		relFields = append(relFields, f)
	}
	sort.Slice(relFields, func(i, j int) bool {
		return relFields[i].Name < relFields[j].Name
	})

	for _, f := range relFields {
		rels := m.Relations[f]

		r := make([]string, 0, len(rels))
		check := make([]string, 0, len(rels))
		for _, v := range rels {
			if f.Null {
				r = append(r, "*v."+schema.ToCamel(v.Name))
			} else {
				r = append(r, "v."+schema.ToCamel(v.Name))
			}
			check = append(check, "v."+schema.ToCamel(v.Name)+" != nil")
		}
		src.WriteString("{\n")
		if f.Null {
			src.WriteString(fmt.Sprintf("if %s {\n", strings.Join(check, " && ")))
		}
		s := strings.Split(f.Type, ".")
		src.WriteString(fmt.Sprintf("rel, err := d.%s.Select(ctx, %s)\n", schema.ToLowerCamel(s[len(s)-1]), strings.Join(r, ",")))
		src.WriteString("if err != nil {\n")
		src.WriteString("return nil, xerrors.Errorf(\": %w\", err)\n")
		src.WriteString("}\n")
		src.WriteString(fmt.Sprintf("v.%s = rel\n", schema.ToCamel(f.Name)))
		if f.Null {
			src.WriteString("}\n")
		}
		src.WriteString("}\n")
	}
	src.WriteRune('\n')
}

func (g GoDAOGenerator) findArgs(fields []*schema.Field, stmt *sqlparser.Where) []*schema.Field {
	fieldMap := make(map[string]*schema.Field)
	for _, v := range fields {
		fieldMap[v.Name] = v
	}

	res := g.findArgFieldFromExprIfExist(fieldMap, stmt.Expr)
	if len(res) == 0 {
		return nil
	}

	return res
}

func (g GoDAOGenerator) findArgFieldFromExprIfExist(fields map[string]*schema.Field, stmt sqlparser.Expr) []*schema.Field {
	res := make([]*schema.Field, 0)
	switch v := stmt.(type) {
	case *sqlparser.ComparisonExpr:
		f := g.findArgFieldFromComparisonExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	case *sqlparser.AndExpr:
		f := g.findArgFieldFromAndExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	case *sqlparser.OrExpr:
		f := g.findArgFieldFromOrExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	default:
		log.Printf("%T", v)
	}

	return res
}

func (GoDAOGenerator) findArgFieldFromComparisonExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.ComparisonExpr) []*schema.Field {
	res := make([]*schema.Field, 0)
	if left, ok := stmt.Left.(*sqlparser.ColName); ok {
		switch r := stmt.Right.(type) {
		case *sqlparser.SQLVal:
			if r.Type == sqlparser.ValArg {
				if f, ok := fields[left.Name.String()]; ok {
					res = append(res, f)
				}
			}
		}
	}

	return res
}

func (g GoDAOGenerator) findArgFieldFromAndExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.AndExpr) []*schema.Field {
	res := make([]*schema.Field, 0)

	for _, s := range []sqlparser.Expr{stmt.Left, stmt.Right} {
		f := g.findArgFieldFromExprIfExist(fields, s)
		if len(f) > 0 {
			res = append(res, f...)
		}
	}

	return res
}

func (g GoDAOGenerator) findArgFieldFromOrExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.OrExpr) []*schema.Field {
	res := make([]*schema.Field, 0)

	for _, s := range []sqlparser.Expr{stmt.Left, stmt.Right} {
		f := g.findArgFieldFromExprIfExist(fields, s)
		if len(f) > 0 {
			res = append(res, f...)
		}
	}

	return res
}

func printSelectQueryAST(m *schema.Message, stmt *sqlparser.Select) string {
	buf := sqlparser.NewTrackedBuffer(func(buf *sqlparser.TrackedBuffer, node sqlparser.SQLNode) {
		switch v := node.(type) {
		case *sqlparser.SQLVal:
			if v.Type == sqlparser.ValArg {
				buf.WriteString("?")
				return
			}
		case sqlparser.TableName:
			if v.Name.String() == ":table_name:" {
				v.Name = sqlparser.NewTableIdent(m.TableName)
				v.Format(buf)
				return
			}
		}

		node.Format(buf)
	})
	stmt.Format(buf)

	return buf.String()
}

type goFunc struct {
	Receiver *field
	Name     string
	Args     fieldList
	Body     string
	Returns  fieldList
}

func (f *goFunc) String() string {
	src := newBuffer()
	src.Buffer.WriteString("func")
	if f.Receiver != nil {
		src.Buffer.WriteString(" (" + f.Receiver.String() + ")")
	}
	src.Buffer.WriteString(" " + f.Name)
	switch len(f.Args) {
	case 0:
		src.Buffer.WriteString("()")
	case 1:
		src.Buffer.WriteRune('(')
		src.Buffer.WriteString(f.Args.String())
		src.Buffer.WriteRune(')')
	default:
		src.Buffer.WriteString(f.Args.String())
	}
	src.Buffer.WriteString(fmt.Sprintf(" %s {\n", f.Returns.String()))
	src.Buffer.WriteString(f.Body)
	src.Write("}")

	return src.String()
}

type field struct {
	Name     string
	Type     string
	Slice    bool
	Variable bool
	Pointer  bool
}

func (n *field) Copy() *field {
	v := &field{}
	*v = *n

	return v
}

func (n *field) String() string {
	v := ""
	if n.Name != "" {
		v += n.Name + " "
	}
	if n.Slice {
		v += "[]"
	}
	if n.Variable {
		v += "..."
	}
	if n.Pointer {
		v += "*"
	}

	v += n.Type
	return v
}

type fieldList []*field

func (n fieldList) String() string {
	s := make([]string, 0)
	for _, v := range n {
		s = append(s, v.String())
	}

	if len(s) == 1 {
		return s[0]
	}
	return "(" + strings.Join(s, ",") + ")"
}

type GoDAOStruct struct {
	m                 *schema.Message
	entityPackageName string
}

func (s *GoDAOStruct) PrimaryKeySelect(
	body func(entityPackageName string, m *schema.Message, args, where, whereArgs []string) string,
) *goFunc {
	funcArgs := fieldList{{Name: "ctx", Type: "context.Context"}}
	args := make([]string, 0)
	where := make([]string, 0)
	whereArgs := make([]string, 0)
	for _, v := range s.m.PrimaryKeys {
		funcArgs = append(funcArgs, &field{Name: schema.ToLowerCamel(v.Name), Type: GoDataTypeMap[v.Type]})

		args = append(args, fmt.Sprintf("%s %s", schema.ToLowerCamel(v.Name), GoDataTypeMap[v.Type]))
		where = append(where, fmt.Sprintf("`%s` = ?", v.Name))
		whereArgs = append(whereArgs, schema.ToLowerCamel(v.Name))
	}

	return &goFunc{
		Name:     "Select",
		Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
		Args:     funcArgs,
		Body:     body(s.entityPackageName, s.m, args, where, whereArgs),
		Returns: []*field{
			{Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
			{Type: "error"},
		},
	}
}

func (s *GoDAOStruct) Select(
	body func(m *schema.Message, name string, stmt *sqlparser.Select, comp []*schema.Field, cols, args []string, entityName string, single bool) string,
) []*goFunc {
	funcs := make([]*goFunc, 0)

	for _, q := range s.m.SelectQueries {
		stmt, err := sqlparser.Parse(q.Query)
		if err != nil {
			log.Printf("Failed parse query %s: %v", q.Query, err)
			continue
		}

		switch v := stmt.(type) {
		case *sqlparser.Select:
			f := s.selectQuery(v, q.Name, body)
			if f != nil {
				funcs = append(funcs, f)
			}
		default:
			log.Printf("%q is not supported: %s", v, q)
		}
	}

	return funcs
}

func (s *GoDAOStruct) Create(body func(m *schema.Message, f *goFunc) string) *goFunc {
	funcArgs := fieldList{
		{Name: "ctx", Type: "context.Context"},
		{Name: schema.ToLowerCamel(s.m.Descriptor.GetName()), Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
		{Name: "opt", Type: "ExecOption", Variable: true},
	}

	f := &goFunc{
		Name:     "Create",
		Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
		Args:     funcArgs,
		Returns: fieldList{
			{Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
			{Type: "error"},
		},
	}
	f.Body = body(s.m, f)

	return f
}

func (s *GoDAOStruct) Delete(body func(m *schema.Message, f *goFunc, where, whereArgs []string) string) *goFunc {
	funcArgs := fieldList{{Name: "ctx", Type: "context.Context"}}
	where := make([]string, 0)
	whereArgs := make([]string, 0)
	for _, v := range s.m.PrimaryKeys {
		funcArgs = append(funcArgs, &field{Name: schema.ToLowerCamel(v.Name), Type: GoDataTypeMap[v.Type]})
		where = append(where, fmt.Sprintf("`%s` = ?", v.Name))
		whereArgs = append(whereArgs, schema.ToLowerCamel(v.Name))
	}
	funcArgs = append(funcArgs, &field{Name: "opt", Type: "ExecOption", Variable: true})

	f := &goFunc{
		Name:     "Delete",
		Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
		Args:     funcArgs,
		Returns:  fieldList{{Type: "error"}},
	}
	f.Body = body(s.m, f, where, whereArgs)

	return f
}

func (s *GoDAOStruct) Update(body func(m *schema.Message, f *goFunc) string) *goFunc {
	funcArgs := fieldList{
		{Name: "ctx", Type: "context.Context"},
		{Name: schema.ToLowerCamel(s.m.Descriptor.GetName()), Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
		{Name: "opt", Type: "ExecOption", Variable: true},
	}

	f := &goFunc{
		Name:     "Update",
		Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
		Args:     funcArgs,
		Returns:  fieldList{{Type: "error"}},
	}
	f.Body = body(s.m, f)

	return f
}

func (s *GoDAOStruct) selectQuery(
	stmt *sqlparser.Select,
	name string,
	body func(m *schema.Message, name string, stmt *sqlparser.Select, comp []*schema.Field, cols, args []string, entityName string, single bool) string,
) *goFunc {
	if len(stmt.From) != 1 {
		log.Printf("Multiple tables is not supported")
		return nil
	}

	allColumn := false
	var cols []string
	for _, c := range stmt.SelectExprs {
		if _, ok := c.(*sqlparser.StarExpr); ok {
			allColumn = true
			cols = nil
			break
		}

		co, ok := c.(*sqlparser.AliasedExpr)
		if !ok {
			log.Printf("%v is %v", c, reflect.TypeOf(c))
			continue
		}
		col, ok := co.Expr.(*sqlparser.ColName)
		if !ok {
			log.Printf("%v is not ColName", c)
			continue
		}
		cols = append(cols, col.Name.String())
	}
	if allColumn {
		cols = make([]string, 0)
		stmt.SelectExprs = make([]sqlparser.SelectExpr, 0)
		for _, v := range s.m.Fields.List() {
			cols = append(cols, v.Name)
			stmt.SelectExprs = append(stmt.SelectExprs, &sqlparser.AliasedExpr{
				Expr: &sqlparser.ColName{
					Name: sqlparser.NewColIdent(v.Name),
				},
			})
		}
	}

	var comp []*schema.Field
	if stmt.Where != nil {
		comp = s.findArgs(s.m.Fields.List(), stmt.Where)
	}

	isReturningSingleRow := s.m.IsReturningSingleRow(comp...)
	funcArgs := make([]*field, 0)
	args := make([]string, len(comp))
	for i := range comp {
		funcArgs = append(funcArgs, &field{Name: schema.ToLowerCamel(comp[i].Name), Type: GoDataTypeMap[comp[i].Type]})
		args[i] = fmt.Sprintf("%s %s", schema.ToLowerCamel(comp[i].Name), GoDataTypeMap[comp[i].Type])
	}
	if !isReturningSingleRow {
		args = append(args, "opt ...ListOption")
	}

	if isReturningSingleRow {
		return &goFunc{
			Name:     "Select" + name,
			Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
			Body:     body(s.m, "Select"+name, stmt, comp, cols, args, s.entityPackageName, true),
			Args:     append([]*field{{Name: "ctx", Type: "context.Context"}}, funcArgs...),
			Returns: []*field{
				{Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
				{Type: "error"},
			},
		}
	} else {
		funcArgs = append([]*field{{Name: "ctx", Type: "context.Context"}}, funcArgs...)
		funcArgs = append(funcArgs, &field{Name: "opt", Variable: true, Type: "ListOption"})

		return &goFunc{
			Name:     "List" + name,
			Receiver: &field{Name: "d", Type: s.m.Descriptor.GetName(), Pointer: true},
			Body:     body(s.m, "List"+name, stmt, comp, cols, args, s.entityPackageName, false),
			Args:     funcArgs,
			Returns: []*field{
				{Slice: true, Type: s.entityPackageName + "." + s.m.Descriptor.GetName(), Pointer: true},
				{Type: "error"},
			},
		}
	}
}

func (s *GoDAOStruct) findArgs(fields []*schema.Field, stmt *sqlparser.Where) []*schema.Field {
	fieldMap := make(map[string]*schema.Field)
	for _, v := range fields {
		fieldMap[v.Name] = v
	}

	res := s.findArgFieldFromExprIfExist(fieldMap, stmt.Expr)
	if len(res) == 0 {
		return nil
	}

	return res
}

func (s *GoDAOStruct) findArgFieldFromExprIfExist(fields map[string]*schema.Field, stmt sqlparser.Expr) []*schema.Field {
	res := make([]*schema.Field, 0)
	switch v := stmt.(type) {
	case *sqlparser.ComparisonExpr:
		f := s.findArgFieldFromComparisonExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	case *sqlparser.AndExpr:
		f := s.findArgFieldFromAndExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	case *sqlparser.OrExpr:
		f := s.findArgFieldFromOrExprIfExist(fields, v)
		if len(f) > 0 {
			res = append(res, f...)
		}
	default:
		log.Printf("%T", v)
	}

	return res
}

func (*GoDAOStruct) findArgFieldFromComparisonExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.ComparisonExpr) []*schema.Field {
	res := make([]*schema.Field, 0)
	if left, ok := stmt.Left.(*sqlparser.ColName); ok {
		switch r := stmt.Right.(type) {
		case *sqlparser.SQLVal:
			if r.Type == sqlparser.ValArg {
				if f, ok := fields[left.Name.String()]; ok {
					res = append(res, f)
				}
			}
		}
	}

	return res
}

func (s *GoDAOStruct) findArgFieldFromAndExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.AndExpr) []*schema.Field {
	res := make([]*schema.Field, 0)

	for _, st := range []sqlparser.Expr{stmt.Left, stmt.Right} {
		f := s.findArgFieldFromExprIfExist(fields, st)
		if len(f) > 0 {
			res = append(res, f...)
		}
	}

	return res
}

func (s *GoDAOStruct) findArgFieldFromOrExprIfExist(fields map[string]*schema.Field, stmt *sqlparser.OrExpr) []*schema.Field {
	res := make([]*schema.Field, 0)

	for _, st := range []sqlparser.Expr{stmt.Left, stmt.Right} {
		f := s.findArgFieldFromExprIfExist(fields, st)
		if len(f) > 0 {
			res = append(res, f...)
		}
	}

	return res
}
