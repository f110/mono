// Generated by protoc-ddl.
// protoc-gen-entity: v0.1
package database

import (
	"bytes"
	"sync"
	"time"

	"go.f110.dev/protoc-ddl"
)

var _ = time.Time{}
var _ = bytes.Buffer{}

type Column struct {
	Name  string
	Value interface{}
}

type SourceRepository struct {
	Id        int32
	Url       string
	CloneUrl  string
	Name      string
	Private   bool
	CreatedAt time.Time
	UpdatedAt *time.Time

	mu   sync.Mutex
	mark *SourceRepository
}

func (e *SourceRepository) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *SourceRepository) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Url != e.mark.Url ||
		e.CloneUrl != e.mark.CloneUrl ||
		e.Name != e.mark.Name ||
		e.Private != e.mark.Private ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *SourceRepository) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Url != e.mark.Url {
		res = append(res, ddl.Column{Name: "url", Value: e.Url})
	}
	if e.CloneUrl != e.mark.CloneUrl {
		res = append(res, ddl.Column{Name: "clone_url", Value: e.CloneUrl})
	}
	if e.Name != e.mark.Name {
		res = append(res, ddl.Column{Name: "name", Value: e.Name})
	}
	if e.Private != e.mark.Private {
		res = append(res, ddl.Column{Name: "private", Value: e.Private})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *SourceRepository) Copy() *SourceRepository {
	n := &SourceRepository{
		Id:        e.Id,
		Url:       e.Url,
		CloneUrl:  e.CloneUrl,
		Name:      e.Name,
		Private:   e.Private,
		CreatedAt: e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type Task struct {
	Id               int32
	RepositoryId     int32
	JobName          string
	JobConfiguration string
	Revision         string
	BazelVersion     string
	Success          bool
	LogFile          string
	Command          string
	// Deprecated.
	Target     string
	Targets    string
	Platform   string
	Via        string
	ConfigName string
	Node       string
	Manifest   string
	StartAt    *time.Time
	FinishedAt *time.Time
	CreatedAt  time.Time
	UpdatedAt  *time.Time

	Repository *SourceRepository

	mu   sync.Mutex
	mark *Task
}

func (e *Task) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *Task) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.RepositoryId != e.mark.RepositoryId ||
		e.JobName != e.mark.JobName ||
		e.JobConfiguration != e.mark.JobConfiguration ||
		e.Revision != e.mark.Revision ||
		e.BazelVersion != e.mark.BazelVersion ||
		e.Success != e.mark.Success ||
		e.LogFile != e.mark.LogFile ||
		e.Command != e.mark.Command ||
		e.Target != e.mark.Target ||
		e.Targets != e.mark.Targets ||
		e.Platform != e.mark.Platform ||
		e.Via != e.mark.Via ||
		e.ConfigName != e.mark.ConfigName ||
		e.Node != e.mark.Node ||
		e.Manifest != e.mark.Manifest ||
		((e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil)) ||
		((e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil)) ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *Task) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.RepositoryId != e.mark.RepositoryId {
		res = append(res, ddl.Column{Name: "repository_id", Value: e.RepositoryId})
	}
	if e.JobName != e.mark.JobName {
		res = append(res, ddl.Column{Name: "job_name", Value: e.JobName})
	}
	if e.JobConfiguration != e.mark.JobConfiguration {
		res = append(res, ddl.Column{Name: "job_configuration", Value: e.JobConfiguration})
	}
	if e.Revision != e.mark.Revision {
		res = append(res, ddl.Column{Name: "revision", Value: e.Revision})
	}
	if e.BazelVersion != e.mark.BazelVersion {
		res = append(res, ddl.Column{Name: "bazel_version", Value: e.BazelVersion})
	}
	if e.Success != e.mark.Success {
		res = append(res, ddl.Column{Name: "success", Value: e.Success})
	}
	if e.LogFile != e.mark.LogFile {
		res = append(res, ddl.Column{Name: "log_file", Value: e.LogFile})
	}
	if e.Command != e.mark.Command {
		res = append(res, ddl.Column{Name: "command", Value: e.Command})
	}
	if e.Target != e.mark.Target {
		res = append(res, ddl.Column{Name: "target", Value: e.Target})
	}
	if e.Targets != e.mark.Targets {
		res = append(res, ddl.Column{Name: "targets", Value: e.Targets})
	}
	if e.Platform != e.mark.Platform {
		res = append(res, ddl.Column{Name: "platform", Value: e.Platform})
	}
	if e.Via != e.mark.Via {
		res = append(res, ddl.Column{Name: "via", Value: e.Via})
	}
	if e.ConfigName != e.mark.ConfigName {
		res = append(res, ddl.Column{Name: "config_name", Value: e.ConfigName})
	}
	if e.Node != e.mark.Node {
		res = append(res, ddl.Column{Name: "node", Value: e.Node})
	}
	if e.Manifest != e.mark.Manifest {
		res = append(res, ddl.Column{Name: "manifest", Value: e.Manifest})
	}
	if (e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil) {
		if e.StartAt != nil {
			res = append(res, ddl.Column{Name: "start_at", Value: *e.StartAt})
		} else {
			res = append(res, ddl.Column{Name: "start_at", Value: nil})
		}
	}
	if (e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil) {
		if e.FinishedAt != nil {
			res = append(res, ddl.Column{Name: "finished_at", Value: *e.FinishedAt})
		} else {
			res = append(res, ddl.Column{Name: "finished_at", Value: nil})
		}
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *Task) Copy() *Task {
	n := &Task{
		Id:               e.Id,
		RepositoryId:     e.RepositoryId,
		JobName:          e.JobName,
		JobConfiguration: e.JobConfiguration,
		Revision:         e.Revision,
		BazelVersion:     e.BazelVersion,
		Success:          e.Success,
		LogFile:          e.LogFile,
		Command:          e.Command,
		Target:           e.Target,
		Targets:          e.Targets,
		Platform:         e.Platform,
		Via:              e.Via,
		ConfigName:       e.ConfigName,
		Node:             e.Node,
		Manifest:         e.Manifest,
		CreatedAt:        e.CreatedAt,
	}
	if e.StartAt != nil {
		v := *e.StartAt
		n.StartAt = &v
	}
	if e.FinishedAt != nil {
		v := *e.FinishedAt
		n.FinishedAt = &v
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	if e.Repository != nil {
		n.Repository = e.Repository.Copy()
	}

	return n
}

type TrustedUser struct {
	Id        int32
	GithubId  int64
	Username  string
	CreatedAt time.Time
	UpdatedAt *time.Time

	mu   sync.Mutex
	mark *TrustedUser
}

func (e *TrustedUser) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *TrustedUser) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.GithubId != e.mark.GithubId ||
		e.Username != e.mark.Username ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *TrustedUser) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.GithubId != e.mark.GithubId {
		res = append(res, ddl.Column{Name: "github_id", Value: e.GithubId})
	}
	if e.Username != e.mark.Username {
		res = append(res, ddl.Column{Name: "username", Value: e.Username})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *TrustedUser) Copy() *TrustedUser {
	n := &TrustedUser{
		Id:        e.Id,
		GithubId:  e.GithubId,
		Username:  e.Username,
		CreatedAt: e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type PermitPullRequest struct {
	Id         int32
	Repository string
	Number     int32
	CreatedAt  time.Time
	UpdatedAt  *time.Time

	mu   sync.Mutex
	mark *PermitPullRequest
}

func (e *PermitPullRequest) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *PermitPullRequest) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Repository != e.mark.Repository ||
		e.Number != e.mark.Number ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *PermitPullRequest) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Repository != e.mark.Repository {
		res = append(res, ddl.Column{Name: "repository", Value: e.Repository})
	}
	if e.Number != e.mark.Number {
		res = append(res, ddl.Column{Name: "number", Value: e.Number})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *PermitPullRequest) Copy() *PermitPullRequest {
	n := &PermitPullRequest{
		Id:         e.Id,
		Repository: e.Repository,
		Number:     e.Number,
		CreatedAt:  e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}
