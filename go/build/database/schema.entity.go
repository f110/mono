// Generated by protoc-ddl.
// protoc-gen-entity: v0.1
package database

import (
	"bytes"
	"sync"
	"time"

	"go.f110.dev/protoc-ddl"
)

var _ = time.Time{}
var _ = bytes.Buffer{}

type SourceRepositoryStatus uint32

const (
	SourceRepositoryStatusUnknown            SourceRepositoryStatus = 0
	SourceRepositoryStatusReady              SourceRepositoryStatus = 1
	SourceRepositoryStatusInvalidBuildConfig SourceRepositoryStatus = 2
)

type TestStatus uint32

const (
	TestStatusPassed TestStatus = 0
	TestStatusFlaky  TestStatus = 1
	TestStatusFailed TestStatus = 2
)

type SourceRepository struct {
	Id            int32
	Url           string
	CloneUrl      string
	Name          string
	Private       bool
	Status        SourceRepositoryStatus
	DefaultBranch string
	CreatedAt     time.Time
	UpdatedAt     *time.Time

	mu   sync.Mutex
	mark *SourceRepository
}

func (e *SourceRepository) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *SourceRepository) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Url != e.mark.Url ||
		e.CloneUrl != e.mark.CloneUrl ||
		e.Name != e.mark.Name ||
		e.Private != e.mark.Private ||
		e.Status != e.mark.Status ||
		e.DefaultBranch != e.mark.DefaultBranch ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *SourceRepository) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Url != e.mark.Url {
		res = append(res, ddl.Column{Name: "url", Value: e.Url})
	}
	if e.CloneUrl != e.mark.CloneUrl {
		res = append(res, ddl.Column{Name: "clone_url", Value: e.CloneUrl})
	}
	if e.Name != e.mark.Name {
		res = append(res, ddl.Column{Name: "name", Value: e.Name})
	}
	if e.Private != e.mark.Private {
		res = append(res, ddl.Column{Name: "private", Value: e.Private})
	}
	if e.Status != e.mark.Status {
		res = append(res, ddl.Column{Name: "status", Value: e.Status})
	}
	if e.DefaultBranch != e.mark.DefaultBranch {
		res = append(res, ddl.Column{Name: "default_branch", Value: e.DefaultBranch})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *SourceRepository) Copy() *SourceRepository {
	n := &SourceRepository{
		Id:            e.Id,
		Url:           e.Url,
		CloneUrl:      e.CloneUrl,
		Name:          e.Name,
		Private:       e.Private,
		Status:        e.Status,
		DefaultBranch: e.DefaultBranch,
		CreatedAt:     e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type Task struct {
	Id           int32
	RepositoryId int32
	JobName      string
	// Deprecated.
	JobConfiguration       *string
	ParsedJobConfiguration []byte
	Revision               string
	IsTrunk                bool
	BazelVersion           string
	Success                bool
	LogFile                string
	Command                string
	// Deprecated.
	Target              string
	Targets             string
	Platform            string
	Via                 string
	ConfigName          string
	Node                string
	JobObjectName       string
	Manifest            string
	Container           string
	ExecutedTestsCount  int32
	SucceededTestsCount int32
	StartAt             *time.Time
	FinishedAt          *time.Time
	CreatedAt           time.Time
	UpdatedAt           *time.Time

	Repository *SourceRepository

	mu   sync.Mutex
	mark *Task
}

func (e *Task) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *Task) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.RepositoryId != e.mark.RepositoryId ||
		e.JobName != e.mark.JobName ||
		((e.JobConfiguration != nil && (e.mark.JobConfiguration == nil || *e.JobConfiguration != *e.mark.JobConfiguration)) || e.JobConfiguration == nil && e.mark.JobConfiguration != nil) ||
		!bytes.Equal(e.ParsedJobConfiguration, e.mark.ParsedJobConfiguration) ||
		e.Revision != e.mark.Revision ||
		e.IsTrunk != e.mark.IsTrunk ||
		e.BazelVersion != e.mark.BazelVersion ||
		e.Success != e.mark.Success ||
		e.LogFile != e.mark.LogFile ||
		e.Command != e.mark.Command ||
		e.Target != e.mark.Target ||
		e.Targets != e.mark.Targets ||
		e.Platform != e.mark.Platform ||
		e.Via != e.mark.Via ||
		e.ConfigName != e.mark.ConfigName ||
		e.Node != e.mark.Node ||
		e.JobObjectName != e.mark.JobObjectName ||
		e.Manifest != e.mark.Manifest ||
		e.Container != e.mark.Container ||
		e.ExecutedTestsCount != e.mark.ExecutedTestsCount ||
		e.SucceededTestsCount != e.mark.SucceededTestsCount ||
		((e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil)) ||
		((e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil)) ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *Task) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.RepositoryId != e.mark.RepositoryId {
		res = append(res, ddl.Column{Name: "repository_id", Value: e.RepositoryId})
	}
	if e.JobName != e.mark.JobName {
		res = append(res, ddl.Column{Name: "job_name", Value: e.JobName})
	}
	if (e.JobConfiguration != nil && (e.mark.JobConfiguration == nil || *e.JobConfiguration != *e.mark.JobConfiguration)) || (e.JobConfiguration == nil && e.mark.JobConfiguration != nil) {
		if e.JobConfiguration != nil {
			res = append(res, ddl.Column{Name: "job_configuration", Value: *e.JobConfiguration})
		} else {
			res = append(res, ddl.Column{Name: "job_configuration", Value: nil})
		}
	}
	if !bytes.Equal(e.ParsedJobConfiguration, e.mark.ParsedJobConfiguration) {
		res = append(res, ddl.Column{Name: "parsed_job_configuration", Value: e.ParsedJobConfiguration})
	}
	if e.Revision != e.mark.Revision {
		res = append(res, ddl.Column{Name: "revision", Value: e.Revision})
	}
	if e.IsTrunk != e.mark.IsTrunk {
		res = append(res, ddl.Column{Name: "is_trunk", Value: e.IsTrunk})
	}
	if e.BazelVersion != e.mark.BazelVersion {
		res = append(res, ddl.Column{Name: "bazel_version", Value: e.BazelVersion})
	}
	if e.Success != e.mark.Success {
		res = append(res, ddl.Column{Name: "success", Value: e.Success})
	}
	if e.LogFile != e.mark.LogFile {
		res = append(res, ddl.Column{Name: "log_file", Value: e.LogFile})
	}
	if e.Command != e.mark.Command {
		res = append(res, ddl.Column{Name: "command", Value: e.Command})
	}
	if e.Target != e.mark.Target {
		res = append(res, ddl.Column{Name: "target", Value: e.Target})
	}
	if e.Targets != e.mark.Targets {
		res = append(res, ddl.Column{Name: "targets", Value: e.Targets})
	}
	if e.Platform != e.mark.Platform {
		res = append(res, ddl.Column{Name: "platform", Value: e.Platform})
	}
	if e.Via != e.mark.Via {
		res = append(res, ddl.Column{Name: "via", Value: e.Via})
	}
	if e.ConfigName != e.mark.ConfigName {
		res = append(res, ddl.Column{Name: "config_name", Value: e.ConfigName})
	}
	if e.Node != e.mark.Node {
		res = append(res, ddl.Column{Name: "node", Value: e.Node})
	}
	if e.JobObjectName != e.mark.JobObjectName {
		res = append(res, ddl.Column{Name: "job_object_name", Value: e.JobObjectName})
	}
	if e.Manifest != e.mark.Manifest {
		res = append(res, ddl.Column{Name: "manifest", Value: e.Manifest})
	}
	if e.Container != e.mark.Container {
		res = append(res, ddl.Column{Name: "container", Value: e.Container})
	}
	if e.ExecutedTestsCount != e.mark.ExecutedTestsCount {
		res = append(res, ddl.Column{Name: "executed_tests_count", Value: e.ExecutedTestsCount})
	}
	if e.SucceededTestsCount != e.mark.SucceededTestsCount {
		res = append(res, ddl.Column{Name: "succeeded_tests_count", Value: e.SucceededTestsCount})
	}
	if (e.StartAt != nil && (e.mark.StartAt == nil || !e.StartAt.Equal(*e.mark.StartAt))) || (e.StartAt == nil && e.mark.StartAt != nil) {
		if e.StartAt != nil {
			res = append(res, ddl.Column{Name: "start_at", Value: *e.StartAt})
		} else {
			res = append(res, ddl.Column{Name: "start_at", Value: nil})
		}
	}
	if (e.FinishedAt != nil && (e.mark.FinishedAt == nil || !e.FinishedAt.Equal(*e.mark.FinishedAt))) || (e.FinishedAt == nil && e.mark.FinishedAt != nil) {
		if e.FinishedAt != nil {
			res = append(res, ddl.Column{Name: "finished_at", Value: *e.FinishedAt})
		} else {
			res = append(res, ddl.Column{Name: "finished_at", Value: nil})
		}
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *Task) Copy() *Task {
	n := &Task{
		Id:                     e.Id,
		RepositoryId:           e.RepositoryId,
		JobName:                e.JobName,
		ParsedJobConfiguration: e.ParsedJobConfiguration,
		Revision:               e.Revision,
		IsTrunk:                e.IsTrunk,
		BazelVersion:           e.BazelVersion,
		Success:                e.Success,
		LogFile:                e.LogFile,
		Command:                e.Command,
		Target:                 e.Target,
		Targets:                e.Targets,
		Platform:               e.Platform,
		Via:                    e.Via,
		ConfigName:             e.ConfigName,
		Node:                   e.Node,
		JobObjectName:          e.JobObjectName,
		Manifest:               e.Manifest,
		Container:              e.Container,
		ExecutedTestsCount:     e.ExecutedTestsCount,
		SucceededTestsCount:    e.SucceededTestsCount,
		CreatedAt:              e.CreatedAt,
	}
	if e.JobConfiguration != nil {
		v := *e.JobConfiguration
		n.JobConfiguration = &v
	}
	if e.StartAt != nil {
		v := *e.StartAt
		n.StartAt = &v
	}
	if e.FinishedAt != nil {
		v := *e.FinishedAt
		n.FinishedAt = &v
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	if e.Repository != nil {
		n.Repository = e.Repository.Copy()
	}

	return n
}

type TrustedUser struct {
	Id        int32
	GithubId  int64
	Username  string
	CreatedAt time.Time
	UpdatedAt *time.Time

	mu   sync.Mutex
	mark *TrustedUser
}

func (e *TrustedUser) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *TrustedUser) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.GithubId != e.mark.GithubId ||
		e.Username != e.mark.Username ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *TrustedUser) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.GithubId != e.mark.GithubId {
		res = append(res, ddl.Column{Name: "github_id", Value: e.GithubId})
	}
	if e.Username != e.mark.Username {
		res = append(res, ddl.Column{Name: "username", Value: e.Username})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *TrustedUser) Copy() *TrustedUser {
	n := &TrustedUser{
		Id:        e.Id,
		GithubId:  e.GithubId,
		Username:  e.Username,
		CreatedAt: e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type PermitPullRequest struct {
	Id         int32
	Repository string
	Number     int32
	CreatedAt  time.Time
	UpdatedAt  *time.Time

	mu   sync.Mutex
	mark *PermitPullRequest
}

func (e *PermitPullRequest) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *PermitPullRequest) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.Repository != e.mark.Repository ||
		e.Number != e.mark.Number ||
		!e.CreatedAt.Equal(e.mark.CreatedAt) ||
		((e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil))
}

func (e *PermitPullRequest) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.Repository != e.mark.Repository {
		res = append(res, ddl.Column{Name: "repository", Value: e.Repository})
	}
	if e.Number != e.mark.Number {
		res = append(res, ddl.Column{Name: "number", Value: e.Number})
	}
	if !e.CreatedAt.Equal(e.mark.CreatedAt) {
		res = append(res, ddl.Column{Name: "created_at", Value: e.CreatedAt})
	}
	if (e.UpdatedAt != nil && (e.mark.UpdatedAt == nil || !e.UpdatedAt.Equal(*e.mark.UpdatedAt))) || (e.UpdatedAt == nil && e.mark.UpdatedAt != nil) {
		if e.UpdatedAt != nil {
			res = append(res, ddl.Column{Name: "updated_at", Value: *e.UpdatedAt})
		} else {
			res = append(res, ddl.Column{Name: "updated_at", Value: nil})
		}
	}

	return res
}

func (e *PermitPullRequest) Copy() *PermitPullRequest {
	n := &PermitPullRequest{
		Id:         e.Id,
		Repository: e.Repository,
		Number:     e.Number,
		CreatedAt:  e.CreatedAt,
	}
	if e.UpdatedAt != nil {
		v := *e.UpdatedAt
		n.UpdatedAt = &v
	}

	return n
}

type TestReport struct {
	Id           int32
	RepositoryId int32
	TaskId       int32
	Label        string
	Status       TestStatus
	Duration     int64
	StartAt      time.Time

	Repository *SourceRepository
	Task       *Task

	mu   sync.Mutex
	mark *TestReport
}

func (e *TestReport) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *TestReport) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return e.RepositoryId != e.mark.RepositoryId ||
		e.TaskId != e.mark.TaskId ||
		e.Label != e.mark.Label ||
		e.Status != e.mark.Status ||
		e.Duration != e.mark.Duration ||
		!e.StartAt.Equal(e.mark.StartAt)
}

func (e *TestReport) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)
	if e.RepositoryId != e.mark.RepositoryId {
		res = append(res, ddl.Column{Name: "repository_id", Value: e.RepositoryId})
	}
	if e.TaskId != e.mark.TaskId {
		res = append(res, ddl.Column{Name: "task_id", Value: e.TaskId})
	}
	if e.Label != e.mark.Label {
		res = append(res, ddl.Column{Name: "label", Value: e.Label})
	}
	if e.Status != e.mark.Status {
		res = append(res, ddl.Column{Name: "status", Value: e.Status})
	}
	if e.Duration != e.mark.Duration {
		res = append(res, ddl.Column{Name: "duration", Value: e.Duration})
	}
	if !e.StartAt.Equal(e.mark.StartAt) {
		res = append(res, ddl.Column{Name: "start_at", Value: e.StartAt})
	}

	return res
}

func (e *TestReport) Copy() *TestReport {
	n := &TestReport{
		Id:           e.Id,
		RepositoryId: e.RepositoryId,
		TaskId:       e.TaskId,
		Label:        e.Label,
		Status:       e.Status,
		Duration:     e.Duration,
		StartAt:      e.StartAt,
	}

	if e.Repository != nil {
		n.Repository = e.Repository.Copy()
	}
	if e.Task != nil {
		n.Task = e.Task.Copy()
	}

	return n
}

// Job table stores the job definition for manually triggerable jobs defined in the default branch.
type Job struct {
	RepositoryId int32
	Name         string

	Repository *SourceRepository

	mu   sync.Mutex
	mark *Job
}

func (e *Job) ResetMark() {
	e.mu.Lock()
	defer e.mu.Unlock()

	e.mark = e.Copy()
}

func (e *Job) IsChanged() bool {
	e.mu.Lock()
	defer e.mu.Unlock()

	return false
}

func (e *Job) ChangedColumn() []ddl.Column {
	e.mu.Lock()
	defer e.mu.Unlock()

	res := make([]ddl.Column, 0)

	return res
}

func (e *Job) Copy() *Job {
	n := &Job{
		RepositoryId: e.RepositoryId,
		Name:         e.Name,
	}

	if e.Repository != nil {
		n.Repository = e.Repository.Copy()
	}

	return n
}
