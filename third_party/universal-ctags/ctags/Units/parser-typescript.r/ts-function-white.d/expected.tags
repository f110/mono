point	input.ts	/^function point(x: number, y: number): Point {$/;"	f
x	input.ts	/^function point(x: number, y: number): Point {$/;"	z	function:point
y	input.ts	/^function point(x: number, y: number): Point {$/;"	z	function:point
equals	input.ts	/^export function equals(p1: Point, p2: Point) {$/;"	f
p1	input.ts	/^export function equals(p1: Point, p2: Point) {$/;"	z	function:equals
p2	input.ts	/^export function equals(p1: Point, p2: Point) {$/;"	z	function:equals
message	input.ts	/^export function message(s: string) {$/;"	f
s	input.ts	/^export function message(s: string) {$/;"	z	function:message
point	input.ts	/^export default function point(x: number, y: number) {$/;"	f
x	input.ts	/^export default function point(x: number, y: number) {$/;"	z	function:point
y	input.ts	/^export default function point(x: number, y: number) {$/;"	z	function:point
numberToString	input.ts	/^function numberToString(a: number[]) {$/;"	f
a	input.ts	/^function numberToString(a: number[]) {$/;"	z	function:numberToString
stringArray	input.ts	/^  var stringArray = a.map(v => v.toString())$/;"	l	function:numberToString
g	input.ts	/^function *g(): Iterable<string> {$/;"	G
i	input.ts	/^  for (var i = 0; i < 100; i++) {$/;"	l	generator:g
h	input.ts	/^function *h(limit) {$/;"	G
limit	input.ts	/^function *h(limit) {$/;"	z	generator:h
i	input.ts	/^  for (var i = 0; i < limit; i++) {$/;"	l	generator:h
fn	input.ts	/^async function fn(): Promise<number> {  $/;"	f
i	input.ts	/^  var i = await p \/\/ suspend execution until 'p' is settled. 'i' has type "number"  $/;"	l	function:fn
isCat	input.ts	/^function isCat(a: Animal): a is Cat {$/;"	f
a	input.ts	/^function isCat(a: Animal): a is Cat {$/;"	z	function:isCat
foo	input.ts	/^var foo = function() {$/;"	v
foo2	input.ts	/^var foo2 = () => {$/;"	v
