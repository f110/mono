X	input.go	/^type X struct {$/;"	s
T1	input.go	/^	T1$/;"	M	struct:X	typeref:typename:T1
T2	input.go	/^	*T2$/;"	M	struct:X	typeref:typename:*T2
T3	input.go	/^	P.T3$/;"	M	struct:X	typeref:typename:P.T3
T4	input.go	/^	*P.T4$/;"	M	struct:X	typeref:typename:*P.T4
age	input.go	/^	age T5$/;"	m	struct:X	typeref:typename:T5
skill	input.go	/^	skill *T6$/;"	m	struct:X	typeref:typename:*T6
address	input.go	/^	address, hometown T7$/;"	m	struct:X	typeref:typename:T7
hometown	input.go	/^	address, hometown T7$/;"	m	struct:X	typeref:typename:T7
natualLang	input.go	/^	natualLang,programmingLang *T8$/;"	m	struct:X	typeref:typename:*T8
programmingLang	input.go	/^	natualLang,programmingLang *T8$/;"	m	struct:X	typeref:typename:*T8
person	input.go	/^	person P.T9$/;"	m	struct:X	typeref:typename:P.T9
parent	input.go	/^	parent *P.T10$/;"	m	struct:X	typeref:typename:*P.T10
lang1	input.go	/^	lang1, lang2 P.LANG$/;"	m	struct:X	typeref:typename:P.LANG
lang2	input.go	/^	lang1, lang2 P.LANG$/;"	m	struct:X	typeref:typename:P.LANG
lang3	input.go	/^	lang3, lang4 *P.LANG$/;"	m	struct:X	typeref:typename:*P.LANG
lang4	input.go	/^	lang3, lang4 *P.LANG$/;"	m	struct:X	typeref:typename:*P.LANG
Q	input.go	/^	P.Q$/;"	M	struct:X	typeref:typename:P.Q
Q	input.go	/^	*P.Q$/;"	M	struct:X	typeref:typename:*P.Q
Y	input.go	/^type Y struct {$/;"	s
byte	input.go	/^	byte$/;"	M	struct:Y	typeref:typename:byte
b	input.go	/^	b byte$/;"	m	struct:Y	typeref:typename:byte
ss	input.go	/^	ss []string$/;"	m	struct:Y	typeref:typename:[]string
bss	input.go	/^	bss [][]byte$/;"	m	struct:Y	typeref:typename:[][]byte
f	input.go	/^	f func() error$/;"	m	struct:Y	typeref:typename:func() error
ifaces	input.go	/^	ifaces []interface{}$/;"	m	struct:Y	typeref:typename:[]interface{}
tags	input.go	/^	tags  map[string]struct{}$/;"	m	struct:Y	typeref:typename:map[string]struct{}
notify	input.go	/^	notify chan<- struct{}$/;"	m	struct:Y	typeref:typename:chan<- struct{}
p	input.go	/^	p *struct {$/;"	m	struct:Y	typeref:typename:*struct { x int; y int; z int; }
