badger	input.vhd	/^package body badger is$/;"	P
badger2	input.vhd	/^package body badger2 is$/;"	P
accumulator	input.vhd	/^entity accumulator is port ($/;"	e
a	input.vhd	/^  a: in std_logic_vector(3 downto 0);$/;"	q	entity:accumulator
clk	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:accumulator
reset	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:accumulator
accum	input.vhd	/^  accum: out std_logic_vector(3 downto 0)$/;"	q	entity:accumulator
simple	input.vhd	/^architecture simple of accumulator is$/;"	a	entity:accumulator
accumL	input.vhd	/^signal accumL: unsigned(3 downto 0);$/;"	s	architecture:accumulator.simple
accumulate	input.vhd	/^  accumulate: process (clk, reset) begin$/;"	Q	architecture:accumulator.simple
adder	input.vhd	/^entity adder is port ($/;"	e
a	input.vhd	/^  a,b : in std_logic_vector (15 downto 0);$/;"	q	entity:adder
b	input.vhd	/^  a,b : in std_logic_vector (15 downto 0);$/;"	q	entity:adder
sum	input.vhd	/^  sum: out std_logic_vector (15 downto 0)$/;"	q	entity:adder
dataflow	input.vhd	/^architecture dataflow of adder is$/;"	a	entity:adder
pAdderAttr	input.vhd	/^entity pAdderAttr is$/;"	e
n	input.vhd	/^  generic(n : integer := 8);$/;"	g	entity:pAdderAttr
a	input.vhd	/^  port (a    : in std_logic_vector(n - 1 downto 0);$/;"	q	entity:pAdderAttr
b	input.vhd	/^        b    : in std_logic_vector(n - 1 downto 0);$/;"	q	entity:pAdderAttr
cin	input.vhd	/^        cin  : in std_logic;$/;"	q	entity:pAdderAttr
sum	input.vhd	/^        sum  : out std_logic_vector(n - 1 downto 0);$/;"	q	entity:pAdderAttr
cout	input.vhd	/^        cout : out std_logic);$/;"	q	entity:pAdderAttr
loopDemo	input.vhd	/^architecture loopDemo of pAdderAttr is$/;"	a	entity:pAdderAttr
anonProcesscfc8de98010f	input.vhd	/^  process(a, b, cin)$/;"	Q	architecture:pAdderAttr.loopDemo
carry	input.vhd	/^    variable carry: std_logic_vector(sum'length downto 0);$/;"	v	process:pAdderAttr.loopDemo.anonProcesscfc8de98010f
localSum	input.vhd	/^    variable localSum: std_logic_vector(sum'high downto 0);$/;"	v	process:pAdderAttr.loopDemo.anonProcesscfc8de98010f
adder	input.vhd	/^entity adder is port ($/;"	e
a	input.vhd	/^  a,b: in unsigned(3 downto 0);$/;"	q	entity:adder
b	input.vhd	/^  a,b: in unsigned(3 downto 0);$/;"	q	entity:adder
sum	input.vhd	/^  sum: out unsigned(3 downto 0)$/;"	q	entity:adder
simple	input.vhd	/^architecture simple of adder is$/;"	a	entity:adder
AND2	input.vhd	/^entity AND2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:AND2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:AND2
rtl	input.vhd	/^architecture rtl of AND2 is$/;"	a	entity:AND2
asyncLoad	input.vhd	/^entity asyncLoad is port ($/;"	e
loadVal	input.vhd	/^  loadVal, d: in std_logic_vector(3 downto 0);$/;"	q	entity:asyncLoad
d	input.vhd	/^  loadVal, d: in std_logic_vector(3 downto 0);$/;"	q	entity:asyncLoad
clk	input.vhd	/^  clk, load: in std_logic;$/;"	q	entity:asyncLoad
load	input.vhd	/^  clk, load: in std_logic;$/;"	q	entity:asyncLoad
q	input.vhd	/^  q: out std_logic_vector(3 downto 0)$/;"	q	entity:asyncLoad
rtl	input.vhd	/^architecture rtl of asyncLoad is$/;"	a	entity:asyncLoad
anonProcesscfc8de98020f	input.vhd	/^  process (clk, load, loadVal) begin$/;"	Q	architecture:asyncLoad.rtl
BidirBuf	input.vhd	/^entity BidirBuf is port ($/;"	e
OE	input.vhd	/^  OE: in std_logic;$/;"	q	entity:BidirBuf
input	input.vhd	/^  input: in std_logic_vector;$/;"	q	entity:BidirBuf
output	input.vhd	/^  output: out std_logic_vector$/;"	q	entity:BidirBuf
behavioral	input.vhd	/^architecture behavioral of BidirBuf is$/;"	a	entity:BidirBuf
bidirBuf	input.vhd	/^  bidirBuf: process (OE, input) begin$/;"	Q	architecture:BidirBuf.behavioral
BidirCnt	input.vhd	/^entity BidirCnt is port ($/;"	e
OE	input.vhd	/^  OE: in std_logic;$/;"	q	entity:BidirCnt
CntEnable	input.vhd	/^  CntEnable: in std_logic;$/;"	q	entity:BidirCnt
LdCnt	input.vhd	/^  LdCnt: in std_logic;$/;"	q	entity:BidirCnt
Clk	input.vhd	/^  Clk: in std_logic;$/;"	q	entity:BidirCnt
Rst	input.vhd	/^  Rst: in std_logic;$/;"	q	entity:BidirCnt
Cnt	input.vhd	/^  Cnt: inout std_logic_vector(3 downto 0)$/;"	q	entity:BidirCnt
behavioral	input.vhd	/^architecture behavioral of BidirCnt is$/;"	a	entity:BidirCnt
LoadCnt	input.vhd	/^  component LoadCnt port ($/;"	C	architecture:BidirCnt.behavioral
CntEn	input.vhd	/^    CntEn: in std_logic;$/;"	q	component:BidirCnt.behavioral.LoadCnt
LdCnt	input.vhd	/^    LdCnt: in std_logic;$/;"	q	component:BidirCnt.behavioral.LoadCnt
LdData	input.vhd	/^    LdData: in std_logic_vector(3 downto 0);$/;"	q	component:BidirCnt.behavioral.LoadCnt
Clk	input.vhd	/^    Clk: in std_logic;$/;"	q	component:BidirCnt.behavioral.LoadCnt
Rst	input.vhd	/^    Rst: in std_logic;$/;"	q	component:BidirCnt.behavioral.LoadCnt
CntVal	input.vhd	/^    CntVal: out std_logic_vector(3 downto 0)$/;"	q	component:BidirCnt.behavioral.LoadCnt
BidirBuf	input.vhd	/^  component BidirBuf port ($/;"	C	architecture:BidirCnt.behavioral
OE	input.vhd	/^    OE: in std_logic;$/;"	q	component:BidirCnt.behavioral.BidirBuf
input	input.vhd	/^    input: in std_logic_vector;$/;"	q	component:BidirCnt.behavioral.BidirBuf
output	input.vhd	/^    output: inout std_logic_vector$/;"	q	component:BidirCnt.behavioral.BidirBuf
CntVal	input.vhd	/^signal CntVal: std_logic_vector(3 downto 0);$/;"	s	architecture:BidirCnt.behavioral
LoadVal	input.vhd	/^signal LoadVal: std_logic_vector(3 downto 0);$/;"	s	architecture:BidirCnt.behavioral
BIDIR	input.vhd	/^entity BIDIR is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:BIDIR
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:BIDIR
op_fb	input.vhd	/^  op_fb: out std_logic;$/;"	q	entity:BIDIR
op	input.vhd	/^  op: inout std_logic$/;"	q	entity:BIDIR
rtl	input.vhd	/^architecture rtl of BIDIR is$/;"	a	entity:BIDIR
bidirbuffer	input.vhd	/^entity bidirbuffer is port ($/;"	e
input	input.vhd	/^  input: in std_logic;$/;"	q	entity:bidirbuffer
enable	input.vhd	/^  enable: in std_logic;$/;"	q	entity:bidirbuffer
feedback	input.vhd	/^  feedback: out std_logic;$/;"	q	entity:bidirbuffer
output	input.vhd	/^  output: inout std_logic$/;"	q	entity:bidirbuffer
structural	input.vhd	/^architecture structural of bidirbuffer is$/;"	a	entity:bidirbuffer
clkGen	input.vhd	/^entity clkGen is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:clkGen
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:clkGen
ClkDiv2	input.vhd	/^  ClkDiv2, ClkDiv4,$/;"	q	entity:clkGen
ClkDiv4	input.vhd	/^  ClkDiv2, ClkDiv4,$/;"	q	entity:clkGen
ClkDiv6	input.vhd	/^  ClkDiv6,ClkDiv8: out std_logic$/;"	q	entity:clkGen
ClkDiv8	input.vhd	/^  ClkDiv6,ClkDiv8: out std_logic$/;"	q	entity:clkGen
behav	input.vhd	/^architecture behav of clkGen is$/;"	a	entity:clkGen
numClks	input.vhd	/^subtype numClks is std_logic_vector(1 to 4);$/;"	T	architecture:clkGen.behav
numPatterns	input.vhd	/^subtype numPatterns is integer range 0 to 11;$/;"	T	architecture:clkGen.behav
clkTableType	input.vhd	/^type clkTableType is array (numpatterns'low to numPatterns'high) of numClks;$/;"	t	architecture:clkGen.behav
clkTable	input.vhd	/^constant clkTable: clkTableType := clkTableType'($/;"	c	architecture:clkGen.behav
index	input.vhd	/^signal index: numPatterns;$/;"	s	architecture:clkGen.behav
lookupTable	input.vhd	/^  lookupTable: process (clk, reset) begin$/;"	Q	architecture:clkGen.behav
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
enable	input.vhd	/^  enable: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: buffer unsigned(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
count8	input.vhd	/^entity count8 is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:count8
rst	input.vhd	/^  rst: in std_logic;$/;"	q	entity:count8
count	input.vhd	/^  count: out std_logic_vector(7 downto 0)$/;"	q	entity:count8
structural	input.vhd	/^architecture structural of count8 is$/;"	a	entity:count8
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(0 to 9)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(0 to 9);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(9 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(9 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
load	input.vhd	/^  load: in std_logic;$/;"	q	entity:counter
enable	input.vhd	/^  enable: in std_logic;$/;"	q	entity:counter
data	input.vhd	/^  data: in std_logic_vector(3 downto 0);$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
load	input.vhd	/^  load: in std_logic;$/;"	q	entity:counter
data	input.vhd	/^  data: in std_logic_vector(3 downto 0);$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
Cnt4Term	input.vhd	/^entity Cnt4Term is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:Cnt4Term
Cnt	input.vhd	/^  Cnt: out std_logic_vector(3 downto 0);$/;"	q	entity:Cnt4Term
TermCnt	input.vhd	/^  TermCnt: out std_logic$/;"	q	entity:Cnt4Term
behavioral	input.vhd	/^architecture behavioral of Cnt4Term is$/;"	a	entity:Cnt4Term
CntL	input.vhd	/^signal CntL: unsigned(3 downto 0);$/;"	s	architecture:Cnt4Term.behavioral
increment	input.vhd	/^  increment: process begin$/;"	Q	architecture:Cnt4Term.behavioral
Counter	input.vhd	/^entity Counter is port ($/;"	e
clock	input.vhd	/^  clock: in std_logic;$/;"	q	entity:Counter
Count	input.vhd	/^  Count: out std_logic_vector(3 downto 0)$/;"	q	entity:Counter
structural	input.vhd	/^architecture structural of Counter is$/;"	a	entity:Counter
Cnt4Term	input.vhd	/^  component Cnt4Term port ($/;"	C	architecture:Counter.structural
clk	input.vhd	/^    clk: in std_logic;$/;"	q	component:Counter.structural.Cnt4Term
Cnt	input.vhd	/^    Cnt: out std_logic_vector(3 downto 0);$/;"	q	component:Counter.structural.Cnt4Term
TermCnt	input.vhd	/^    TermCnt: out std_logic);$/;"	q	component:Counter.structural.Cnt4Term
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk) begin$/;"	Q	architecture:counter.simple
convertArith	input.vhd	/^entity convertArith is port ($/;"	e
truncate	input.vhd	/^  truncate: out unsigned(3 downto 0);$/;"	q	entity:convertArith
extend	input.vhd	/^  extend: out unsigned(15 downto 0);$/;"	q	entity:convertArith
direction	input.vhd	/^  direction: out unsigned(0 to 7)$/;"	q	entity:convertArith
simple	input.vhd	/^architecture simple of convertArith is$/;"	a	entity:convertArith
Const	input.vhd	/^constant Const: unsigned(7 downto 0) := "00111010";$/;"	c	architecture:convertArith.simple
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
concurrent	input.vhd	/^architecture concurrent of FEWGATES is$/;"	a	entity:FEWGATES
THREE	input.vhd	/^constant THREE: std_logic_vector(1 downto 0) := "11";$/;"	c	architecture:FEWGATES.concurrent
typeConvert	input.vhd	/^entity typeConvert is port ($/;"	e
a	input.vhd	/^  a: out unsigned(7 downto 0)$/;"	q	entity:typeConvert
simple	input.vhd	/^architecture simple of typeConvert is$/;"	a	entity:typeConvert
Const	input.vhd	/^constant Const: natural := 43;$/;"	c	architecture:typeConvert.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(0 to 3)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(0 to 3);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
counter	input.vhd	/^entity counter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:counter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:counter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:counter
simple	input.vhd	/^architecture simple of counter is$/;"	a	entity:counter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:counter.simple
increment	input.vhd	/^  increment: process (clk, reset) begin$/;"	Q	architecture:counter.simple
decoder	input.vhd	/^entity decoder is port ($/;"	e
decIn	input.vhd	/^  decIn: in std_logic_vector(1 downto 0);$/;"	q	entity:decoder
decOut	input.vhd	/^  decOut: out std_logic_vector(3 downto 0)$/;"	q	entity:decoder
simple	input.vhd	/^architecture simple of decoder is$/;"	a	entity:decoder
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:          in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
decOut_n	input.vhd	/^  decOut_n:         out std_logic_vector(5 downto 0)$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)    := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)    := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
sio_dec_n	input.vhd	/^  alias sio_dec_n: std_logic is        decOut_n(5);$/;"	A	architecture:isa_dec.synthesis
rst_ctrl_rd_n	input.vhd	/^  alias rst_ctrl_rd_n: std_logic is    decOut_n(4);$/;"	A	architecture:isa_dec.synthesis
atc_stat_rd_n	input.vhd	/^  alias atc_stat_rd_n: std_logic is    decOut_n(3);$/;"	A	architecture:isa_dec.synthesis
mgmt_stat_rd_n	input.vhd	/^  alias mgmt_stat_rd_n: std_logic is   decOut_n(2);$/;"	A	architecture:isa_dec.synthesis
io_int_stat_rd_n	input.vhd	/^  alias io_int_stat_rd_n: std_logic is decOut_n(1);$/;"	A	architecture:isa_dec.synthesis
int_ctrl_rd_n	input.vhd	/^  alias int_ctrl_rd_n: std_logic is    decOut_n(0);$/;"	A	architecture:isa_dec.synthesis
upper	input.vhd	/^  alias upper: std_logic_vector(2 downto 0) is dev_adr(19 downto 17);$/;"	A	architecture:isa_dec.synthesis
CtrlBits	input.vhd	/^  alias CtrlBits: std_logic_vector(16 downto 0) is dev_adr(16 downto 0);$/;"	A	architecture:isa_dec.synthesis
decoder	input.vhd	/^  decoder: process (upper, CtrlBits)$/;"	Q	architecture:isa_dec.synthesis
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:          in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:        out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:    out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:    out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n: out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:    out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)    := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)    := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
decoder	input.vhd	/^  decoder: process (dev_adr)$/;"	Q	architecture:isa_dec.synthesis
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:         in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:       out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:   out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:  out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n:out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:   out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)  := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)  := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:          in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
cs0_n	input.vhd	/^  cs0_n:            in std_logic;$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:        out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:    out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:    out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n: out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:    out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)    := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)    := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
decoder	input.vhd	/^  decoder: process (dev_adr, cs0_n)$/;"	Q	architecture:isa_dec.synthesis
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:          in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
cs0_n	input.vhd	/^  cs0_n:            in std_logic;$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:        out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:    out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:    out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n: out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:    out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)    := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)    := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
Lsio_dec_n	input.vhd	/^  signal Lsio_dec_n:        std_logic;$/;"	s	architecture:isa_dec.synthesis
Lrst_ctrl_rd_n	input.vhd	/^  signal Lrst_ctrl_rd_n:    std_logic;$/;"	s	architecture:isa_dec.synthesis
Latc_stat_rd_n	input.vhd	/^  signal Latc_stat_rd_n:    std_logic;$/;"	s	architecture:isa_dec.synthesis
Lmgmt_stat_rd_n	input.vhd	/^  signal Lmgmt_stat_rd_n:   std_logic;$/;"	s	architecture:isa_dec.synthesis
Lio_int_stat_rd_n	input.vhd	/^  signal Lio_int_stat_rd_n: std_logic;$/;"	s	architecture:isa_dec.synthesis
Lint_ctrl_rd_n	input.vhd	/^  signal Lint_ctrl_rd_n:    std_logic;$/;"	s	architecture:isa_dec.synthesis
decoder	input.vhd	/^  decoder: process (dev_adr)$/;"	Q	architecture:isa_dec.synthesis
qualify	input.vhd	/^  qualify: process (cs0_n) begin$/;"	Q	architecture:isa_dec.synthesis
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:          in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:        out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:    out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:    out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n: out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:    out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)    := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)    := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
decoder	input.vhd	/^  decoder: process ( dev_adr)$/;"	Q	architecture:isa_dec.synthesis
decProcs	input.vhd	/^package decProcs is$/;"	P
decProcs	input.vhd	/^package body decProcs is$/;"	P
DEC2x4	input.vhd	/^  procedure DEC2x4 (inputs : in std_logic_vector(1 downto 0);$/;"	p	package:decProcs
isa_dec	input.vhd	/^entity isa_dec is port$/;"	e
dev_adr	input.vhd	/^  dev_adr:         in std_logic_vector(19 downto 0);$/;"	q	entity:isa_dec
sio_dec_n	input.vhd	/^  sio_dec_n:       out std_logic;$/;"	q	entity:isa_dec
rst_ctrl_rd_n	input.vhd	/^  rst_ctrl_rd_n:   out std_logic;$/;"	q	entity:isa_dec
atc_stat_rd_n	input.vhd	/^  atc_stat_rd_n:   out std_logic;$/;"	q	entity:isa_dec
mgmt_stat_rd_n	input.vhd	/^  mgmt_stat_rd_n:  out std_logic;$/;"	q	entity:isa_dec
io_int_stat_rd_n	input.vhd	/^  io_int_stat_rd_n:out std_logic;$/;"	q	entity:isa_dec
int_ctrl_rd_n	input.vhd	/^  int_ctrl_rd_n:   out std_logic$/;"	q	entity:isa_dec
synthesis	input.vhd	/^architecture synthesis of isa_dec is$/;"	a	entity:isa_dec
CtrlRegRange	input.vhd	/^  constant  CtrlRegRange: std_logic_vector(2 downto 0)  := "100";$/;"	c	architecture:isa_dec.synthesis
SuperIoRange	input.vhd	/^  constant  SuperIoRange: std_logic_vector(2 downto 0)  := "010";$/;"	c	architecture:isa_dec.synthesis
IntCtrlReg	input.vhd	/^  constant  IntCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000000";$/;"	c	architecture:isa_dec.synthesis
IoIntStatReg	input.vhd	/^  constant  IoIntStatReg: std_logic_vector(16 downto 0) := "00000000000000001";$/;"	c	architecture:isa_dec.synthesis
RstCtrlReg	input.vhd	/^  constant  RstCtrlReg:   std_logic_vector(16 downto 0) := "00000000000000010";$/;"	c	architecture:isa_dec.synthesis
AtcStatusReg	input.vhd	/^  constant  AtcStatusReg: std_logic_vector(16 downto 0) := "00000000000000011";$/;"	c	architecture:isa_dec.synthesis
MgmtStatusReg	input.vhd	/^  constant  MgmtStatusReg:std_logic_vector(16 downto 0) := "00000000000000100";$/;"	c	architecture:isa_dec.synthesis
progPulse	input.vhd	/^entity progPulse is port ($/;"	e
clk	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
reset	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
loadLength	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
loadDelay	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
data	input.vhd	/^  data: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulse
pulse	input.vhd	/^  pulse: out std_logic$/;"	q	entity:progPulse
rtl	input.vhd	/^architecture rtl of progPulse is$/;"	a	entity:progPulse
delayCnt	input.vhd	/^signal delayCnt, pulseCnt: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
pulseCnt	input.vhd	/^signal delayCnt, pulseCnt: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
delayCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
pulseCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
startPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
endPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
delayReg	input.vhd	/^  delayReg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
lengthReg	input.vhd	/^  lengthReg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
pulseDelay	input.vhd	/^  pulseDelay: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
pulseLength	input.vhd	/^  pulseLength: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
pulseOutput	input.vhd	/^  pulseOutput: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
arst	input.vhd	/^    arst : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic;$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98030f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
a	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
b	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
c	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98040f	input.vhd	/^  process (clk, a,b,c) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
a	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
b	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
c	input.vhd	/^    a,b,c : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
localRst	input.vhd	/^signal localRst: std_logic;$/;"	s	architecture:DFF.rtl
anonProcesscfc8de98050f	input.vhd	/^  process (clk, localRst) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
arst	input.vhd	/^    arst: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98060f	input.vhd	/^  process (clk, arst) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
aset	input.vhd	/^    aset : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98070f	input.vhd	/^  process (clk, aset) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d1	input.vhd	/^    d1, d2: in std_logic;$/;"	q	entity:DFF
d2	input.vhd	/^    d1, d2: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
arst	input.vhd	/^    arst : in std_logic;$/;"	q	entity:DFF
q1	input.vhd	/^    q1, q2: out std_logic$/;"	q	entity:DFF
q2	input.vhd	/^    q1, q2: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98080f	input.vhd	/^  process (clk, arst) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98090f	input.vhd	/^  process begin$/;"	Q	architecture:DFF.rtl
DFFE	input.vhd	/^entity DFFE is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFFE
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFFE
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFFE
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFFE
rtl	input.vhd	/^architecture rtl of DFFE is$/;"	a	entity:DFFE
anonProcesscfc8de980a0f	input.vhd	/^  process begin$/;"	Q	architecture:DFFE.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
envector	input.vhd	/^    envector: in std_logic_vector(7 downto 0);$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de980b0f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de980c0f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
DFFE_SR	input.vhd	/^entity DFFE_SR is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFFE_SR
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFFE_SR
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFFE_SR
rst	input.vhd	/^    rst: in std_logic;$/;"	q	entity:DFFE_SR
prst	input.vhd	/^    prst: in std_logic;$/;"	q	entity:DFFE_SR
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFFE_SR
rtl	input.vhd	/^architecture rtl of DFFE_SR is$/;"	a	entity:DFFE_SR
anonProcesscfc8de980d0f	input.vhd	/^  process (clk, rst, prst) begin$/;"	Q	architecture:DFFE_SR.rtl
flipFlop	input.vhd	/^entity flipFlop is port ($/;"	e
clock	input.vhd	/^  clock, input: in std_logic;$/;"	q	entity:flipFlop
input	input.vhd	/^  clock, input: in std_logic;$/;"	q	entity:flipFlop
ffOut	input.vhd	/^  ffOut: out std_logic$/;"	q	entity:flipFlop
simple	input.vhd	/^architecture simple of flipFlop is$/;"	a	entity:flipFlop
dff	input.vhd	/^  procedure dff (signal clk: in std_logic;$/;"	p	architecture:flipFlop.simple
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de980e0f	input.vhd	/^  process begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d1	input.vhd	/^    d1, d2: in std_logic;$/;"	q	entity:DFF
d2	input.vhd	/^    d1, d2: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
srst	input.vhd	/^    srst : in std_logic;$/;"	q	entity:DFF
q1	input.vhd	/^    q1, q2: out std_logic$/;"	q	entity:DFF
q2	input.vhd	/^    q1, q2: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de980f0f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
DFFE_SR	input.vhd	/^entity DFFE_SR is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFFE_SR
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFFE_SR
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFFE_SR
rst	input.vhd	/^    rst: in std_logic;$/;"	q	entity:DFFE_SR
prst	input.vhd	/^    prst: in std_logic;$/;"	q	entity:DFFE_SR
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFFE_SR
rtl	input.vhd	/^architecture rtl of DFFE_SR is$/;"	a	entity:DFFE_SR
anonProcesscfc8de98100f	input.vhd	/^  process (clk, rst, prst) begin$/;"	Q	architecture:DFFE_SR.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
srst	input.vhd	/^    srst : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98110f	input.vhd	/^  process begin$/;"	Q	architecture:DFF.rtl
struct_dffe_sr	input.vhd	/^entity struct_dffe_sr is port ($/;"	e
d	input.vhd	/^  d: in std_logic;$/;"	q	entity:struct_dffe_sr
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:struct_dffe_sr
en	input.vhd	/^  en: in std_logic;$/;"	q	entity:struct_dffe_sr
rst	input.vhd	/^  rst,prst: in std_logic;$/;"	q	entity:struct_dffe_sr
prst	input.vhd	/^  rst,prst: in std_logic;$/;"	q	entity:struct_dffe_sr
q	input.vhd	/^  q: out std_logic$/;"	q	entity:struct_dffe_sr
instance	input.vhd	/^architecture instance of struct_dffe_sr is$/;"	a	entity:struct_dffe_sr
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
srst	input.vhd	/^    srst : in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98120f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
struct_dffe	input.vhd	/^entity struct_dffe is port ($/;"	e
d	input.vhd	/^  d: in std_logic;$/;"	q	entity:struct_dffe
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:struct_dffe
en	input.vhd	/^  en: in std_logic;$/;"	q	entity:struct_dffe
q	input.vhd	/^  q: out std_logic$/;"	q	entity:struct_dffe
instance	input.vhd	/^architecture instance of struct_dffe is$/;"	a	entity:struct_dffe
dffTri	input.vhd	/^entity dffTri is$/;"	e
size	input.vhd	/^  generic (size: integer := 8);$/;"	g	entity:dffTri
data	input.vhd	/^  data: in std_logic_vector(size - 1 downto 0);$/;"	q	entity:dffTri
clock	input.vhd	/^  clock: in std_logic;$/;"	q	entity:dffTri
ff_enable	input.vhd	/^  ff_enable: in std_logic;$/;"	q	entity:dffTri
op_enable	input.vhd	/^  op_enable: in std_logic;$/;"	q	entity:dffTri
qout	input.vhd	/^  qout: out std_logic_vector(size - 1 downto 0)$/;"	q	entity:dffTri
parameterize	input.vhd	/^architecture parameterize of dffTri is$/;"	a	entity:dffTri
tribufType	input.vhd	/^type tribufType is record$/;"	t	architecture:dffTri.parameterize
ip	input.vhd	/^  ip: std_logic;$/;"	r	type:dffTri.parameterize.tribufType
oe	input.vhd	/^  oe: std_logic;$/;"	r	type:dffTri.parameterize.tribufType
op	input.vhd	/^  op: std_logic;$/;"	r	type:dffTri.parameterize.tribufType
tribufArrayType	input.vhd	/^type tribufArrayType is array (integer range <>) of tribufType;$/;"	t	architecture:dffTri.parameterize
tri	input.vhd	/^signal tri: tribufArrayType(size - 1 downto 0);$/;"	s	architecture:dffTri.parameterize
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98130f	input.vhd	/^  process begin$/;"	Q	architecture:DFF.rtl
TRIBUF	input.vhd	/^entity TRIBUF is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:TRIBUF
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF
op	input.vhd	/^  op: out std_logic bus$/;"	q	entity:TRIBUF
sequential	input.vhd	/^architecture sequential of TRIBUF is$/;"	a	entity:TRIBUF
enable	input.vhd	/^  enable: process (ip,oe) begin$/;"	Q	architecture:TRIBUF.sequential
DLATCHH	input.vhd	/^entity DLATCHH is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DLATCHH
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DLATCHH
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DLATCHH
rtl	input.vhd	/^architecture rtl of DLATCHH is$/;"	a	entity:DLATCHH
qLocal	input.vhd	/^signal qLocal: std_logic;$/;"	s	architecture:DLATCHH.rtl
DLATCHH	input.vhd	/^entity DLATCHH is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DLATCHH
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DLATCHH
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DLATCHH
rtl	input.vhd	/^architecture rtl of DLATCHH is$/;"	a	entity:DLATCHH
anonProcesscfc8de98140f	input.vhd	/^  process (en, d) begin$/;"	Q	architecture:DLATCHH.rtl
struct_dlatch	input.vhd	/^entity struct_dlatch is port ($/;"	e
d	input.vhd	/^  d: in std_logic;$/;"	q	entity:struct_dlatch
en	input.vhd	/^  en: in std_logic;$/;"	q	entity:struct_dlatch
q	input.vhd	/^  q: out std_logic$/;"	q	entity:struct_dlatch
instance	input.vhd	/^architecture instance of struct_dlatch is$/;"	a	entity:struct_dlatch
downCounter	input.vhd	/^entity downCounter is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:downCounter
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:downCounter
count	input.vhd	/^  count: out std_logic_vector(3 downto 0)$/;"	q	entity:downCounter
simple	input.vhd	/^architecture simple of downCounter is$/;"	a	entity:downCounter
countL	input.vhd	/^signal countL: unsigned(3 downto 0);$/;"	s	architecture:downCounter.simple
termCnt	input.vhd	/^signal termCnt: std_logic;$/;"	s	architecture:downCounter.simple
decrement	input.vhd	/^  decrement: process (clk, reset) begin$/;"	Q	architecture:downCounter.simple
compareDC	input.vhd	/^entity compareDC is port ($/;"	e
addressBus	input.vhd	/^  addressBus: in std_logic_vector(31 downto 0);$/;"	q	entity:compareDC
addressHit	input.vhd	/^  addressHit: out std_logic$/;"	q	entity:compareDC
wontWork	input.vhd	/^architecture wontWork of compareDC is$/;"	a	entity:compareDC
compare	input.vhd	/^  compare: process(addressBus) begin$/;"	Q	architecture:compareDC.wontWork
encoder	input.vhd	/^entity encoder is$/;"	e
invec	input.vhd	/^        port (invec: in std_logic_vector(7 downto 0);$/;"	q	entity:encoder
enc_out	input.vhd	/^              enc_out: out std_logic_vector(2 downto 0)$/;"	q	entity:encoder
rtl	input.vhd	/^architecture rtl of encoder is$/;"	a	entity:encoder
encode	input.vhd	/^  encode: process (invec) begin$/;"	Q	architecture:encoder.rtl
encoder	input.vhd	/^entity encoder is$/;"	e
invec	input.vhd	/^  port (invec:in std_logic_vector(7 downto 0);$/;"	q	entity:encoder
enc_out	input.vhd	/^        enc_out:out  std_logic_vector(2 downto 0)$/;"	q	entity:encoder
rtl	input.vhd	/^architecture rtl of encoder is$/;"	a	entity:encoder
anonProcesscfc8de98150f	input.vhd	/^  process (invec)$/;"	Q	architecture:encoder.rtl
encoder	input.vhd	/^entity encoder is$/;"	e
invec	input.vhd	/^  port (invec: in std_logic_vector(7 downto 0);$/;"	q	entity:encoder
enc_out	input.vhd	/^        enc_out: out std_logic_vector(2 downto 0)$/;"	q	entity:encoder
rtl	input.vhd	/^architecture rtl of encoder is$/;"	a	entity:encoder
compare	input.vhd	/^entity compare is port ($/;"	e
ina	input.vhd	/^  ina: in std_logic_vector (3 downto 0);$/;"	q	entity:compare
inb	input.vhd	/^  inb: in std_logic_vector (2 downto 0);$/;"	q	entity:compare
equal	input.vhd	/^  equal: out std_logic$/;"	q	entity:compare
simple	input.vhd	/^architecture simple of compare is$/;"	a	entity:compare
equalProc	input.vhd	/^  equalProc: process (ina, inb) begin$/;"	Q	architecture:compare.simple
LogicFcn	input.vhd	/^entity LogicFcn is port ($/;"	e
A	input.vhd	/^  A: in std_logic;$/;"	q	entity:LogicFcn
B	input.vhd	/^  B: in std_logic;$/;"	q	entity:LogicFcn
C	input.vhd	/^  C: in std_logic;$/;"	q	entity:LogicFcn
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:LogicFcn
behavioral	input.vhd	/^architecture behavioral of LogicFcn is$/;"	a	entity:LogicFcn
fcn	input.vhd	/^  fcn: process (A,B,C) begin$/;"	Q	architecture:LogicFcn.behavioral
LogicFcn	input.vhd	/^entity LogicFcn is port ($/;"	e
A	input.vhd	/^  A: in std_logic;$/;"	q	entity:LogicFcn
B	input.vhd	/^  B: in std_logic;$/;"	q	entity:LogicFcn
C	input.vhd	/^  C: in std_logic;$/;"	q	entity:LogicFcn
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:LogicFcn
dataflow	input.vhd	/^architecture dataflow of LogicFcn is$/;"	a	entity:LogicFcn
LogicFcn	input.vhd	/^entity LogicFcn is port ($/;"	e
A	input.vhd	/^  A: in std_logic;$/;"	q	entity:LogicFcn
B	input.vhd	/^  B: in std_logic;$/;"	q	entity:LogicFcn
C	input.vhd	/^  C: in std_logic;$/;"	q	entity:LogicFcn
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:LogicFcn
structural	input.vhd	/^architecture structural of LogicFcn is$/;"	a	entity:LogicFcn
notA	input.vhd	/^signal notA, notB, andSignal: std_logic;$/;"	s	architecture:LogicFcn.structural
notB	input.vhd	/^signal notA, notB, andSignal: std_logic;$/;"	s	architecture:LogicFcn.structural
andSignal	input.vhd	/^signal notA, notB, andSignal: std_logic;$/;"	s	architecture:LogicFcn.structural
SimDFF	input.vhd	/^entity SimDFF is port ($/;"	e
D	input.vhd	/^  D, Clk: in std_logic;$/;"	q	entity:SimDFF
Clk	input.vhd	/^  D, Clk: in std_logic;$/;"	q	entity:SimDFF
Q	input.vhd	/^  Q: out std_logic$/;"	q	entity:SimDFF
SimModel	input.vhd	/^architecture SimModel of SimDFF is$/;"	a	entity:SimDFF
tCQ	input.vhd	/^constant tCQ: time := 8 ns;$/;"	c	architecture:SimDFF.SimModel
tS	input.vhd	/^constant tS:  time := 4 ns;$/;"	c	architecture:SimDFF.SimModel
tH	input.vhd	/^constant tH:  time := 3 ns;$/;"	c	architecture:SimDFF.SimModel
reg	input.vhd	/^  reg: process (Clk, D) begin$/;"	Q	architecture:SimDFF.SimModel
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98160f	input.vhd	/^  process (clk) begin$/;"	Q	architecture:DFF.rtl
DFF	input.vhd	/^entity DFF is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
anonProcesscfc8de98170f	input.vhd	/^  process begin$/;"	Q	architecture:DFF.rtl
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
structural	input.vhd	/^architecture structural of FEWGATES is$/;"	a	entity:FEWGATES
AND2	input.vhd	/^  component AND2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.AND2
OR2	input.vhd	/^  component OR2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.OR2
INVERTER	input.vhd	/^  component INVERTER port ($/;"	C	architecture:FEWGATES.structural
i	input.vhd	/^    i: in std_logic;$/;"	q	component:FEWGATES.structural.INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	component:FEWGATES.structural.INVERTER
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
structural	input.vhd	/^architecture structural of FEWGATES is$/;"	a	entity:FEWGATES
AND2	input.vhd	/^  component AND2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.AND2
OR2	input.vhd	/^  component OR2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.OR2
INVERTER	input.vhd	/^  component INVERTER port ($/;"	C	architecture:FEWGATES.structural
i	input.vhd	/^    i: in std_logic;$/;"	q	component:FEWGATES.structural.INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	component:FEWGATES.structural.INVERTER
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
structural	input.vhd	/^architecture structural of FEWGATES is$/;"	a	entity:FEWGATES
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
concurrent	input.vhd	/^architecture concurrent of FEWGATES is$/;"	a	entity:FEWGATES
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.concurrent
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.concurrent
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.concurrent
GatesPkg	input.vhd	/^package GatesPkg is$/;"	P
AND2	input.vhd	/^  component AND2 port ($/;"	C	package:GatesPkg
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:GatesPkg.AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:GatesPkg.AND2
y	input.vhd	/^    y: out std_logic$/;"	q	component:GatesPkg.AND2
OR2	input.vhd	/^  component OR2 port ($/;"	C	package:GatesPkg
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:GatesPkg.OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:GatesPkg.OR2
y	input.vhd	/^    y: out std_logic$/;"	q	component:GatesPkg.OR2
INVERTER	input.vhd	/^  component INVERTER port ($/;"	C	package:GatesPkg
i	input.vhd	/^    i: in std_logic;$/;"	q	component:GatesPkg.INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	component:GatesPkg.INVERTER
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
structural	input.vhd	/^architecture structural of FEWGATES is$/;"	a	entity:FEWGATES
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
AND2	input.vhd	/^entity AND2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:AND2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:AND2
rtl	input.vhd	/^architecture rtl of AND2 is$/;"	a	entity:AND2
OR2	input.vhd	/^entity OR2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:OR2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:OR2
rtl	input.vhd	/^architecture rtl of OR2 is$/;"	a	entity:OR2
INVERTER	input.vhd	/^entity INVERTER is port ($/;"	e
i	input.vhd	/^    i: in std_logic;$/;"	q	entity:INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	entity:INVERTER
rtl	input.vhd	/^architecture rtl of INVERTER is$/;"	a	entity:INVERTER
FEWGATES	input.vhd	/^entity FEWGATES is port ($/;"	e
a	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
b	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
c	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
d	input.vhd	/^  a,b,c,d: in std_logic;$/;"	q	entity:FEWGATES
y	input.vhd	/^  y: out std_logic$/;"	q	entity:FEWGATES
structural	input.vhd	/^architecture structural of FEWGATES is$/;"	a	entity:FEWGATES
AND2	input.vhd	/^  component AND2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.AND2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.AND2
OR2	input.vhd	/^  component OR2 port ($/;"	C	architecture:FEWGATES.structural
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:FEWGATES.structural.OR2
y	input.vhd	/^    y: out std_logic$/;"	q	component:FEWGATES.structural.OR2
INVERTER	input.vhd	/^  component INVERTER port ($/;"	C	architecture:FEWGATES.structural
i	input.vhd	/^    i: in std_logic;$/;"	q	component:FEWGATES.structural.INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	component:FEWGATES.structural.INVERTER
a_and_b	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
not_c_and_d	input.vhd	/^signal a_and_b, c_and_d, not_c_and_d: std_logic;$/;"	s	architecture:FEWGATES.structural
simHierarchy	input.vhd	/^entity simHierarchy is port ($/;"	e
A	input.vhd	/^  A, B, Clk: in std_logic;$/;"	q	entity:simHierarchy
B	input.vhd	/^  A, B, Clk: in std_logic;$/;"	q	entity:simHierarchy
Clk	input.vhd	/^  A, B, Clk: in std_logic;$/;"	q	entity:simHierarchy
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:simHierarchy
hierarchical	input.vhd	/^architecture hierarchical of simHierarchy is$/;"	a	entity:simHierarchy
ADly	input.vhd	/^signal ADly, BDly, OrGateDly, ClkDly: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
BDly	input.vhd	/^signal ADly, BDly, OrGateDly, ClkDly: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
OrGateDly	input.vhd	/^signal ADly, BDly, OrGateDly, ClkDly: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
ClkDly	input.vhd	/^signal ADly, BDly, OrGateDly, ClkDly: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
OrGate	input.vhd	/^signal OrGate, FlopOut: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
FlopOut	input.vhd	/^signal OrGate, FlopOut: std_logic;$/;"	s	architecture:simHierarchy.hierarchical
INVERTER	input.vhd	/^entity INVERTER is port ($/;"	e
i	input.vhd	/^    i: in std_logic;$/;"	q	entity:INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	entity:INVERTER
rtl	input.vhd	/^architecture rtl of INVERTER is$/;"	a	entity:INVERTER
io1164	input.vhd	/^package io1164 is$/;"	P
io1164	input.vhd	/^package body io1164 is$/;"	P
char2char_t	input.vhd	/^    type char2char_t is array (character'low to character'high) of character;$/;"	t	package:io1164
lowcase	input.vhd	/^    constant lowcase: char2char_t := ($/;"	c	package:io1164
f_logic_to_character_t	input.vhd	/^    type f_logic_to_character_t is $/;"	t	package:io1164
f_logic_to_character	input.vhd	/^    constant f_logic_to_character : f_logic_to_character_t := $/;"	c	package:io1164
x_charcode	input.vhd	/^    constant x_charcode     : integer := -1;$/;"	c	package:io1164
maxoct_charcode	input.vhd	/^    constant maxoct_charcode: integer := 7;$/;"	c	package:io1164
maxhex_charcode	input.vhd	/^    constant maxhex_charcode: integer := 15;$/;"	c	package:io1164
bad_charcode	input.vhd	/^    constant bad_charcode   : integer := integer'left;$/;"	c	package:io1164
digit2int_t	input.vhd	/^    type digit2int_t is $/;"	t	package:io1164
octdigit2int	input.vhd	/^    constant octdigit2int: digit2int_t := ($/;"	c	package:io1164
hexdigit2int	input.vhd	/^    constant hexdigit2int: digit2int_t := ($/;"	c	package:io1164
oct_bits_per_digit	input.vhd	/^    constant oct_bits_per_digit: integer := 3;$/;"	c	package:io1164
hex_bits_per_digit	input.vhd	/^    constant hex_bits_per_digit: integer := 4;$/;"	c	package:io1164
int2octdigit_t	input.vhd	/^    type     int2octdigit_t is $/;"	t	package:io1164
int2octdigit	input.vhd	/^    constant int2octdigit: int2octdigit_t :=$/;"	c	package:io1164
int2hexdigit_t	input.vhd	/^    type     int2hexdigit_t is $/;"	t	package:io1164
int2hexdigit	input.vhd	/^    constant int2hexdigit: int2hexdigit_t :=$/;"	c	package:io1164
oct_logic_vector_t	input.vhd	/^    type     oct_logic_vector_t is$/;"	t	package:io1164
octint2logic_t	input.vhd	/^    type     octint2logic_t is $/;"	t	package:io1164
octint2logic	input.vhd	/^    constant octint2logic  : octint2logic_t := ($/;"	c	package:io1164
hex_logic_vector_t	input.vhd	/^    type     hex_logic_vector_t is$/;"	t	package:io1164
hexint2logic_t	input.vhd	/^    type     hexint2logic_t is $/;"	t	package:io1164
hexint2logic	input.vhd	/^    constant hexint2logic  : hexint2logic_t := ($/;"	c	package:io1164
read	input.vhd	/^    procedure read( l: inout line; value: out std_ulogic; good : out boolean ) is$/;"	p	package:io1164
c	input.vhd	/^        variable c      : character;        -- char read while looping$/;"	v	procedure:io1164.read
m	input.vhd	/^        variable m      : line;             -- safe copy of L$/;"	v	procedure:io1164.read
success	input.vhd	/^        variable success: boolean := false; -- readable version of GOOD$/;"	v	procedure:io1164.read
done	input.vhd	/^        variable done   : boolean := false; -- flag to say done reading chars$/;"	v	procedure:io1164.read
read	input.vhd	/^    procedure read( l: inout line; value: out std_ulogic ) is$/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;  -- internal good flag$/;"	v	procedure:io1164.read
read	input.vhd	/^    procedure read(l    : inout line           ; $/;"	p	package:io1164
m	input.vhd	/^        variable m           : line           ; -- saved copy of L$/;"	v	procedure:io1164.read
success	input.vhd	/^        variable success     : boolean := true; -- readable GOOD$/;"	v	procedure:io1164.read
logic_value	input.vhd	/^        variable logic_value : std_logic      ; -- value for one array element$/;"	v	procedure:io1164.read
c	input.vhd	/^        variable c           : character      ; -- read a character$/;"	v	procedure:io1164.read
read	input.vhd	/^    procedure read(l: inout line; value: out std_logic_vector ) is$/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;$/;"	v	procedure:io1164.read
write	input.vhd	/^    procedure write(l        : inout line          ;$/;"	p	package:io1164
write	input.vhd	/^    procedure write(l        : inout line                   ;$/;"	p	package:io1164
m	input.vhd	/^        variable m: line; -- build up intermediate string$/;"	v	procedure:io1164.write
read_oct	input.vhd	/^    procedure read_oct(l         : inout line            ; $/;"	p	package:io1164
m	input.vhd	/^        variable m               : line                      ; -- safe L$/;"	v	procedure:io1164.read_oct
success	input.vhd	/^        variable success         : boolean            := true; -- readable GOOD$/;"	v	procedure:io1164.read_oct
logic_value	input.vhd	/^        variable logic_value     : std_logic                 ; -- elem value$/;"	v	procedure:io1164.read_oct
c	input.vhd	/^        variable c               : character                 ; -- char read$/;"	v	procedure:io1164.read_oct
charcode	input.vhd	/^        variable charcode        : integer                   ; -- char->int$/;"	v	procedure:io1164.read_oct
oct_logic_vector	input.vhd	/^        variable oct_logic_vector: oct_logic_vector_t        ; -- for 1 digit$/;"	v	procedure:io1164.read_oct
bitpos	input.vhd	/^        variable bitpos          : integer                   ; -- in state vec.$/;"	v	procedure:io1164.read_oct
read_oct	input.vhd	/^    procedure read_oct(l         : inout line            ; $/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;                 -- internal good flag$/;"	v	procedure:io1164.read_oct
write_oct	input.vhd	/^    procedure write_oct(l        : inout line                   ;$/;"	p	package:io1164
m	input.vhd	/^        variable m            : line     ; -- safe copy of L$/;"	v	procedure:io1164.write_oct
goodlength	input.vhd	/^        variable goodlength   : boolean  ; -- array is ok len for this base$/;"	v	procedure:io1164.write_oct
isx	input.vhd	/^        variable isx          : boolean  ; -- an X in this digit$/;"	v	procedure:io1164.write_oct
integer_value	input.vhd	/^        variable integer_value: integer  ; -- accumulate integer value$/;"	v	procedure:io1164.write_oct
c	input.vhd	/^        variable c            : character; -- character read$/;"	v	procedure:io1164.write_oct
charpos	input.vhd	/^        variable charpos      : integer  ; -- index string being contructed$/;"	v	procedure:io1164.write_oct
bitpos	input.vhd	/^        variable bitpos       : integer  ; -- bit index inside digit$/;"	v	procedure:io1164.write_oct
read_hex	input.vhd	/^    procedure read_hex(l         : inout line            ; $/;"	p	package:io1164
m	input.vhd	/^        variable m               : line                      ; -- safe L$/;"	v	procedure:io1164.read_hex
success	input.vhd	/^        variable success         : boolean            := true; -- readable GOOD$/;"	v	procedure:io1164.read_hex
logic_value	input.vhd	/^        variable logic_value     : std_logic                 ; -- elem value$/;"	v	procedure:io1164.read_hex
c	input.vhd	/^        variable c               : character                 ; -- char read$/;"	v	procedure:io1164.read_hex
charcode	input.vhd	/^        variable charcode        : integer                   ; -- char->int$/;"	v	procedure:io1164.read_hex
hex_logic_vector	input.vhd	/^        variable hex_logic_vector: hex_logic_vector_t        ; -- for 1 digit$/;"	v	procedure:io1164.read_hex
bitpos	input.vhd	/^        variable bitpos          : integer                   ; -- in state vec.$/;"	v	procedure:io1164.read_hex
read_hex	input.vhd	/^    procedure read_hex(l         : inout line            ; $/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;                 -- internal good flag$/;"	v	procedure:io1164.read_hex
write_hex	input.vhd	/^    procedure write_hex(l        : inout line                   ;$/;"	p	package:io1164
m	input.vhd	/^        variable m            : line     ; -- safe copy of L$/;"	v	procedure:io1164.write_hex
goodlength	input.vhd	/^        variable goodlength   : boolean  ; -- array is ok len for this base$/;"	v	procedure:io1164.write_hex
isx	input.vhd	/^        variable isx          : boolean  ; -- an X in this digit$/;"	v	procedure:io1164.write_hex
integer_value	input.vhd	/^        variable integer_value: integer  ; -- accumulate integer value$/;"	v	procedure:io1164.write_hex
c	input.vhd	/^        variable c            : character; -- character read$/;"	v	procedure:io1164.write_hex
charpos	input.vhd	/^        variable charpos      : integer  ; -- index string being contructed$/;"	v	procedure:io1164.write_hex
bitpos	input.vhd	/^        variable bitpos       : integer  ; -- bit index inside digit$/;"	v	procedure:io1164.write_hex
read_oct	input.vhd	/^    procedure read_oct(l     : inout line;$/;"	p	package:io1164
pos	input.vhd	/^        variable pos     : integer;$/;"	v	procedure:io1164.read_oct
digit	input.vhd	/^        variable digit   : integer;$/;"	v	procedure:io1164.read_oct
result	input.vhd	/^        variable result  : integer := 0;$/;"	v	procedure:io1164.read_oct
success	input.vhd	/^        variable success : boolean := true;$/;"	v	procedure:io1164.read_oct
c	input.vhd	/^        variable c       : character;$/;"	v	procedure:io1164.read_oct
old_l	input.vhd	/^        variable old_l   : line := l;$/;"	v	procedure:io1164.read_oct
read_oct	input.vhd	/^    procedure read_oct(l     : inout line;$/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;                 -- internal good flag$/;"	v	procedure:io1164.read_oct
read_hex	input.vhd	/^    procedure read_hex(l     : inout line;$/;"	p	package:io1164
pos	input.vhd	/^        variable pos     : integer;$/;"	v	procedure:io1164.read_hex
digit	input.vhd	/^        variable digit   : integer;$/;"	v	procedure:io1164.read_hex
result	input.vhd	/^        variable result  : integer := 0;$/;"	v	procedure:io1164.read_hex
success	input.vhd	/^        variable success : boolean := true;$/;"	v	procedure:io1164.read_hex
c	input.vhd	/^        variable c       : character;$/;"	v	procedure:io1164.read_hex
old_l	input.vhd	/^        variable old_l   : line := l;$/;"	v	procedure:io1164.read_hex
read_hex	input.vhd	/^    procedure read_hex(l     : inout line;$/;"	p	package:io1164
success	input.vhd	/^        variable success: boolean;                 -- internal good flag$/;"	v	procedure:io1164.read_hex
asyncLdCnt	input.vhd	/^entity asyncLdCnt is port ($/;"	e
loadVal	input.vhd	/^  loadVal: in std_logic_vector(3 downto 0);$/;"	q	entity:asyncLdCnt
clk	input.vhd	/^  clk, load: in std_logic;$/;"	q	entity:asyncLdCnt
load	input.vhd	/^  clk, load: in std_logic;$/;"	q	entity:asyncLdCnt
q	input.vhd	/^  q: out std_logic_vector(3 downto 0)$/;"	q	entity:asyncLdCnt
rtl	input.vhd	/^architecture rtl of asyncLdCnt is$/;"	a	entity:asyncLdCnt
qLocal	input.vhd	/^signal qLocal: unsigned(3 downto 0);$/;"	s	architecture:asyncLdCnt.rtl
anonProcesscfc8de98180f	input.vhd	/^  process (clk, load, loadVal) begin$/;"	Q	architecture:asyncLdCnt.rtl
LoadCnt	input.vhd	/^entity LoadCnt is port ($/;"	e
CntEn	input.vhd	/^  CntEn: in std_logic;$/;"	q	entity:LoadCnt
LdCnt	input.vhd	/^  LdCnt: in std_logic;$/;"	q	entity:LoadCnt
LdData	input.vhd	/^  LdData: in std_logic_vector(3 downto 0);$/;"	q	entity:LoadCnt
Clk	input.vhd	/^  Clk: in std_logic;$/;"	q	entity:LoadCnt
Rst	input.vhd	/^  Rst: in std_logic;$/;"	q	entity:LoadCnt
CntVal	input.vhd	/^  CntVal: out std_logic_vector(3 downto 0)$/;"	q	entity:LoadCnt
behavioral	input.vhd	/^architecture behavioral of LoadCnt is$/;"	a	entity:LoadCnt
Cnt	input.vhd	/^signal Cnt: std_logic_vector(3 downto 0);$/;"	s	architecture:LoadCnt.behavioral
counter	input.vhd	/^  counter: process (Clk, Rst) begin$/;"	Q	architecture:LoadCnt.behavioral
loadCntTB	input.vhd	/^entity loadCntTB is$/;"	e
testbench	input.vhd	/^architecture testbench of loadCntTB is$/;"	a	entity:loadCntTB
loadCnt	input.vhd	/^  component loadCnt port ($/;"	C	architecture:loadCntTB.testbench
data	input.vhd	/^    data: in std_logic_vector (7 downto 0);$/;"	q	component:loadCntTB.testbench.loadCnt
load	input.vhd	/^    load: in std_logic;$/;"	q	component:loadCntTB.testbench.loadCnt
clk	input.vhd	/^    clk: in std_logic;$/;"	q	component:loadCntTB.testbench.loadCnt
rst	input.vhd	/^    rst: in std_logic;$/;"	q	component:loadCntTB.testbench.loadCnt
q	input.vhd	/^    q: out std_logic_vector (7 downto 0)$/;"	q	component:loadCntTB.testbench.loadCnt
vectorType	input.vhd	/^type vectorType is record$/;"	t	architecture:loadCntTB.testbench
data	input.vhd	/^  data: std_logic_vector(7 downto 0);$/;"	r	type:loadCntTB.testbench.vectorType
load	input.vhd	/^  load: std_logic;$/;"	r	type:loadCntTB.testbench.vectorType
rst	input.vhd	/^  rst: std_logic;$/;"	r	type:loadCntTB.testbench.vectorType
q	input.vhd	/^  q: std_logic_vector(7 downto 0);$/;"	r	type:loadCntTB.testbench.vectorType
testVector	input.vhd	/^signal testVector: vectorType;$/;"	s	architecture:loadCntTB.testbench
TestClk	input.vhd	/^signal TestClk: std_logic := '0';$/;"	s	architecture:loadCntTB.testbench
Qout	input.vhd	/^signal Qout: std_logic_vector(7 downto 0);$/;"	s	architecture:loadCntTB.testbench
ClkPeriod	input.vhd	/^constant ClkPeriod: time := 100 ns;$/;"	c	architecture:loadCntTB.testbench
readVec	input.vhd	/^  readVec: process$/;"	Q	architecture:loadCntTB.testbench
VectorLine	input.vhd	/^    variable VectorLine: line;$/;"	v	process:loadCntTB.testbench.readVec
VectorValid	input.vhd	/^    variable VectorValid: boolean;$/;"	v	process:loadCntTB.testbench.readVec
vRst	input.vhd	/^    variable vRst: std_logic;$/;"	v	process:loadCntTB.testbench.readVec
vLoad	input.vhd	/^    variable vLoad: std_logic;$/;"	v	process:loadCntTB.testbench.readVec
vData	input.vhd	/^    variable vData: std_logic_vector(7 downto 0);$/;"	v	process:loadCntTB.testbench.readVec
vQ	input.vhd	/^    variable vQ: std_logic_vector(7 downto 0);$/;"	v	process:loadCntTB.testbench.readVec
verify	input.vhd	/^  verify: process (TestClk)$/;"	Q	architecture:loadCntTB.testbench
ErrorMsg	input.vhd	/^  variable ErrorMsg: line;$/;"	v	process:loadCntTB.testbench.verify
loadCnt	input.vhd	/^entity loadCnt is port ($/;"	e
data	input.vhd	/^  data: in std_logic_vector (7 downto 0);$/;"	q	entity:loadCnt
load	input.vhd	/^  load: in std_logic;$/;"	q	entity:loadCnt
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:loadCnt
rst	input.vhd	/^  rst: in std_logic;$/;"	q	entity:loadCnt
q	input.vhd	/^  q: out std_logic_vector (7 downto 0)$/;"	q	entity:loadCnt
rtl	input.vhd	/^architecture rtl of loadCnt is$/;"	a	entity:loadCnt
cnt	input.vhd	/^signal cnt: std_logic_vector (7 downto 0);$/;"	s	architecture:loadCnt.rtl
counter	input.vhd	/^  counter: process (clk, rst) begin$/;"	Q	architecture:loadCnt.rtl
multiplier	input.vhd	/^entity multiplier is port ($/;"	e
a	input.vhd	/^  a,b : in std_logic_vector (15 downto 0);$/;"	q	entity:multiplier
b	input.vhd	/^  a,b : in std_logic_vector (15 downto 0);$/;"	q	entity:multiplier
product	input.vhd	/^  product: out std_logic_vector (31 downto 0)$/;"	q	entity:multiplier
dataflow	input.vhd	/^architecture dataflow of multiplier is$/;"	a	entity:multiplier
mux	input.vhd	/^entity mux is port ($/;"	e
A	input.vhd	/^  A, B, Sel: in std_logic;$/;"	q	entity:mux
B	input.vhd	/^  A, B, Sel: in std_logic;$/;"	q	entity:mux
Sel	input.vhd	/^  A, B, Sel: in std_logic;$/;"	q	entity:mux
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:mux
simModel	input.vhd	/^architecture simModel of mux is$/;"	a	entity:mux
tPD_A	input.vhd	/^constant tPD_A:   time := 10 ns;$/;"	c	architecture:mux.simModel
tPD_B	input.vhd	/^constant tPD_B:   time := 15 ns;$/;"	c	architecture:mux.simModel
tPD_Sel	input.vhd	/^constant tPD_Sel: time := 5 ns;$/;"	c	architecture:mux.simModel
DelayMux	input.vhd	/^  DelayMux: process (A, B, Sel)$/;"	Q	architecture:mux.simModel
localY	input.vhd	/^  variable localY: std_logic; -- Zero delay place holder for Y$/;"	v	process:mux.simModel.DelayMux
ForceShare	input.vhd	/^entity ForceShare is port ($/;"	e
a	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
b	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
c	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
d	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
e	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
f	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
result	input.vhd	/^  result: out std_logic_vector(7 downto 0)$/;"	q	entity:ForceShare
behaviour	input.vhd	/^architecture behaviour of ForceShare is$/;"	a	entity:ForceShare
sum	input.vhd	/^  sum: process (a,c,b,d,e,f)$/;"	Q	architecture:ForceShare.behaviour
TRIBUF8	input.vhd	/^entity TRIBUF8 is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic_vector(7 downto 0);$/;"	q	entity:TRIBUF8
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF8
op	input.vhd	/^  op: out std_logic_vector(7 downto 0)$/;"	q	entity:TRIBUF8
concurrent	input.vhd	/^architecture concurrent of TRIBUF8 is$/;"	a	entity:TRIBUF8
TRIBUF	input.vhd	/^entity TRIBUF is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:TRIBUF
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF
op	input.vhd	/^  op: out std_logic$/;"	q	entity:TRIBUF
concurrent	input.vhd	/^architecture concurrent of TRIBUF is$/;"	a	entity:TRIBUF
TRIBUF8	input.vhd	/^entity TRIBUF8 is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic_vector(7 downto 0);$/;"	q	entity:TRIBUF8
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF8
op	input.vhd	/^  op: out std_logic_vector(7 downto 0)$/;"	q	entity:TRIBUF8
sequential	input.vhd	/^architecture sequential of TRIBUF8 is$/;"	a	entity:TRIBUF8
enable	input.vhd	/^  enable: process (ip,oe) begin$/;"	Q	architecture:TRIBUF8.sequential
TRIBUF	input.vhd	/^entity TRIBUF is port ($/;"	e
ip	input.vhd	/^  ip: in bit;$/;"	q	entity:TRIBUF
oe	input.vhd	/^  oe: in bit;$/;"	q	entity:TRIBUF
op	input.vhd	/^  op: out bit$/;"	q	entity:TRIBUF
sequential	input.vhd	/^architecture sequential of TRIBUF is$/;"	a	entity:TRIBUF
enable	input.vhd	/^  enable: process (ip,oe) begin$/;"	Q	architecture:TRIBUF.sequential
TRIBUF	input.vhd	/^entity TRIBUF is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:TRIBUF
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF
op	input.vhd	/^  op: out std_logic$/;"	q	entity:TRIBUF
sequential	input.vhd	/^architecture sequential of TRIBUF is$/;"	a	entity:TRIBUF
enable	input.vhd	/^  enable: process (ip,oe) begin$/;"	Q	architecture:TRIBUF.sequential
tribuffer	input.vhd	/^entity tribuffer is port ($/;"	e
input	input.vhd	/^  input: in std_logic;$/;"	q	entity:tribuffer
enable	input.vhd	/^  enable: in std_logic;$/;"	q	entity:tribuffer
output	input.vhd	/^  output: out std_logic$/;"	q	entity:tribuffer
structural	input.vhd	/^architecture structural of tribuffer is$/;"	a	entity:tribuffer
oddParityGen	input.vhd	/^entity oddParityGen is$/;"	e
width	input.vhd	/^  generic ( width : integer := 8 );$/;"	g	entity:oddParityGen
ad	input.vhd	/^  port (ad: in std_logic_vector (width - 1 downto 0);$/;"	q	entity:oddParityGen
oddParity	input.vhd	/^        oddParity : out std_logic ) ;$/;"	q	entity:oddParityGen
scaleable	input.vhd	/^architecture scaleable of oddParityGen is$/;"	a	entity:oddParityGen
genXor	input.vhd	/^signal genXor: std_logic_vector(ad'range);$/;"	s	architecture:oddParityGen.scaleable
oddParityLoop	input.vhd	/^entity oddParityLoop is$/;"	e
width	input.vhd	/^  generic ( width : integer := 8 );$/;"	g	entity:oddParityLoop
ad	input.vhd	/^  port (ad: in std_logic_vector (width - 1 downto 0);$/;"	q	entity:oddParityLoop
oddParity	input.vhd	/^        oddParity : out std_logic ) ;$/;"	q	entity:oddParityLoop
scaleable	input.vhd	/^architecture scaleable of oddParityLoop is$/;"	a	entity:oddParityLoop
anonProcesscfc8de98190f	input.vhd	/^  process (ad) $/;"	Q	architecture:oddParityLoop.scaleable
loopXor	input.vhd	/^    variable loopXor: std_logic;$/;"	v	process:oddParityLoop.scaleable.anonProcesscfc8de98190f
OR2	input.vhd	/^entity OR2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:OR2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:OR2
rtl	input.vhd	/^architecture rtl of OR2 is$/;"	a	entity:OR2
OR2	input.vhd	/^entity OR2 is port ($/;"	e
I1	input.vhd	/^  I1, I2: in std_logic;$/;"	q	entity:OR2
I2	input.vhd	/^  I1, I2: in std_logic;$/;"	q	entity:OR2
Y	input.vhd	/^  Y: out std_logic$/;"	q	entity:OR2
simple	input.vhd	/^architecture simple of OR2 is$/;"	a	entity:OR2
simPrimitives	input.vhd	/^package simPrimitives is$/;"	P
OR2	input.vhd	/^  component OR2$/;"	C	package:simPrimitives
tPD	input.vhd	/^    generic (tPD: time := 1 ns);$/;"	g	component:simPrimitives.OR2
I1	input.vhd	/^    port (I1, I2: in std_logic;$/;"	q	component:simPrimitives.OR2
I2	input.vhd	/^    port (I1, I2: in std_logic;$/;"	q	component:simPrimitives.OR2
Y	input.vhd	/^      Y: out std_logic$/;"	q	component:simPrimitives.OR2
OR2	input.vhd	/^entity OR2 is$/;"	e
tPD	input.vhd	/^  generic (tPD: time := 1 ns);$/;"	g	entity:OR2
I1	input.vhd	/^  port (I1, I2: in std_logic;$/;"	q	entity:OR2
I2	input.vhd	/^  port (I1, I2: in std_logic;$/;"	q	entity:OR2
Y	input.vhd	/^    Y: out std_logic$/;"	q	entity:OR2
simple	input.vhd	/^architecture simple of OR2 is$/;"	a	entity:OR2
adder	input.vhd	/^entity adder is port ($/;"	e
a	input.vhd	/^  a,b: in std_logic_vector(3 downto 0);$/;"	q	entity:adder
b	input.vhd	/^  a,b: in std_logic_vector(3 downto 0);$/;"	q	entity:adder
sum	input.vhd	/^  sum: out std_logic_vector(3 downto 0);$/;"	q	entity:adder
overflow	input.vhd	/^  overflow: out std_logic$/;"	q	entity:adder
concat	input.vhd	/^architecture concat of adder is$/;"	a	entity:adder
localSum	input.vhd	/^signal localSum: std_logic_vector(4 downto 0);$/;"	s	architecture:adder.concat
paramDFF	input.vhd	/^entity paramDFF is$/;"	e
size	input.vhd	/^  generic (size: integer := 8);$/;"	g	entity:paramDFF
data	input.vhd	/^  data: in std_logic_vector(size - 1 downto 0);$/;"	q	entity:paramDFF
clock	input.vhd	/^  clock: in std_logic;$/;"	q	entity:paramDFF
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:paramDFF
ff_enable	input.vhd	/^  ff_enable: in std_logic;$/;"	q	entity:paramDFF
op_enable	input.vhd	/^  op_enable: in std_logic;$/;"	q	entity:paramDFF
qout	input.vhd	/^  qout: out std_logic_vector(size - 1 downto 0)$/;"	q	entity:paramDFF
parameterize	input.vhd	/^architecture parameterize of paramDFF is$/;"	a	entity:paramDFF
reg	input.vhd	/^signal reg: std_logic_vector(size - 1 downto 0);$/;"	s	architecture:paramDFF.parameterize
oddParityGen	input.vhd	/^entity oddParityGen is$/;"	e
width	input.vhd	/^  generic ( width : integer := 32 );$/;"	g	entity:oddParityGen
ad	input.vhd	/^  port (ad: in std_logic_vector (width - 1 downto 0);$/;"	q	entity:oddParityGen
oddParity	input.vhd	/^        oddParity : out std_logic ) ;$/;"	q	entity:oddParityGen
scaleable	input.vhd	/^architecture scaleable of oddParityGen is$/;"	a	entity:oddParityGen
genXor	input.vhd	/^signal genXor: std_logic_vector(ad'range);$/;"	s	architecture:oddParityGen.scaleable
one	input.vhd	/^signal one: std_logic := '1';$/;"	s	architecture:oddParityGen.scaleable
oddParityGen	input.vhd	/^entity oddParityGen is$/;"	e
width	input.vhd	/^  generic ( width : integer := 32 ); -- (2 <= width <= 32) and a power of 2$/;"	g	entity:oddParityGen
ad	input.vhd	/^  port (ad: in std_logic_vector (width - 1 downto 0);$/;"	q	entity:oddParityGen
oddParity	input.vhd	/^        oddParity : out std_logic ) ;$/;"	q	entity:oddParityGen
scaleable	input.vhd	/^architecture scaleable of oddParityGen is$/;"	a	entity:oddParityGen
stage0	input.vhd	/^signal stage0: std_logic_vector(31 downto 0);$/;"	s	architecture:oddParityGen.scaleable
stage1	input.vhd	/^signal stage1: std_logic_vector(15 downto 0);$/;"	s	architecture:oddParityGen.scaleable
stage2	input.vhd	/^signal stage2: std_logic_vector(7 downto 0);$/;"	s	architecture:oddParityGen.scaleable
stage3	input.vhd	/^signal stage3: std_logic_vector(3 downto 0);$/;"	s	architecture:oddParityGen.scaleable
stage4	input.vhd	/^signal stage4: std_logic_vector(1 downto 0);$/;"	s	architecture:oddParityGen.scaleable
powerOfFour	input.vhd	/^entity powerOfFour is port($/;"	e
clk	input.vhd	/^  clk      : in  std_logic; $/;"	q	entity:powerOfFour
inputVal	input.vhd	/^  inputVal : in  unsigned(3 downto 0);$/;"	q	entity:powerOfFour
power	input.vhd	/^  power    : out unsigned(15 downto 0)$/;"	q	entity:powerOfFour
behavioral	input.vhd	/^architecture behavioral of powerOfFour is$/;"	a	entity:powerOfFour
Pow	input.vhd	/^   function Pow( N, Exp : integer )  return integer is$/;"	f	architecture:powerOfFour.behavioral
Result	input.vhd	/^      Variable Result   : integer := 1;$/;"	v	function:powerOfFour.behavioral.Pow
inputValInt	input.vhd	/^signal inputValInt: integer range 0 to 15;$/;"	s	architecture:powerOfFour.behavioral
powerL	input.vhd	/^signal powerL: integer range 0 to 65535;$/;"	s	architecture:powerOfFour.behavioral
anonProcesscfc8de981a0f	input.vhd	/^   process begin$/;"	Q	architecture:powerOfFour.behavioral
PowerPkg	input.vhd	/^package PowerPkg is  $/;"	P
Power	input.vhd	/^  component Power port($/;"	C	package:PowerPkg
Clk	input.vhd	/^      Clk                   : in  bit; $/;"	q	component:PowerPkg.Power
inputVal	input.vhd	/^      inputVal              : in  bit_vector(0 to 3);$/;"	q	component:PowerPkg.Power
power	input.vhd	/^      power                 : out bit_vector(0 to 15) );$/;"	q	component:PowerPkg.Power
Power	input.vhd	/^entity Power is port($/;"	e
Clk	input.vhd	/^   Clk                   : in  bit; $/;"	q	entity:Power
inputVal	input.vhd	/^   inputVal              : in  bit_vector(0 to 3);$/;"	q	entity:Power
power	input.vhd	/^   power                 : out bit_vector(0 to 15) );$/;"	q	entity:Power
funky	input.vhd	/^architecture funky of Power is$/;"	a	entity:Power
Pow	input.vhd	/^   function Pow( N, Exp : integer )  return integer is$/;"	f	architecture:Power.funky
Result	input.vhd	/^      Variable Result   : integer := 1;$/;"	v	function:Power.funky.Pow
i	input.vhd	/^      Variable i        : integer := 0;$/;"	v	function:Power.funky.Pow
RollVal	input.vhd	/^   function RollVal(  CntlVal : integer )  return integer is$/;"	f	architecture:Power.funky
anonProcesscfc8de981b0f	input.vhd	/^   process $/;"	Q	architecture:Power.funky
priority_encoder	input.vhd	/^entity priority_encoder is port$/;"	e
interrupts	input.vhd	/^  (interrupts : in  std_logic_vector(7 downto 0);$/;"	q	entity:priority_encoder
priority	input.vhd	/^   priority   : in  std_logic_vector(2 downto 0);$/;"	q	entity:priority_encoder
result	input.vhd	/^   result     : out std_logic_vector(2 downto 0)$/;"	q	entity:priority_encoder
behave	input.vhd	/^architecture behave of priority_encoder is$/;"	a	entity:priority_encoder
anonProcesscfc8de981c0f	input.vhd	/^  process (interrupts)$/;"	Q	architecture:priority_encoder.behave
selectIn	input.vhd	/^     variable selectIn  : integer;$/;"	v	process:priority_encoder.behave.anonProcesscfc8de981c0f
LoopCount	input.vhd	/^     variable LoopCount : integer;$/;"	v	process:priority_encoder.behave.anonProcesscfc8de981c0f
primitive	input.vhd	/^package primitive is$/;"	P
DFFE	input.vhd	/^  component DFFE port ($/;"	C	package:primitive
d	input.vhd	/^    d: in std_logic;$/;"	q	component:primitive.DFFE
q	input.vhd	/^    q: out std_logic;$/;"	q	component:primitive.DFFE
en	input.vhd	/^    en: in std_logic;$/;"	q	component:primitive.DFFE
clk	input.vhd	/^    clk: in std_logic$/;"	q	component:primitive.DFFE
DFFE_SR	input.vhd	/^  component DFFE_SR port ($/;"	C	package:primitive
d	input.vhd	/^    d: in std_logic;$/;"	q	component:primitive.DFFE_SR
en	input.vhd	/^    en: in std_logic;$/;"	q	component:primitive.DFFE_SR
clk	input.vhd	/^    clk: in std_logic;$/;"	q	component:primitive.DFFE_SR
rst	input.vhd	/^    rst: in std_logic;$/;"	q	component:primitive.DFFE_SR
prst	input.vhd	/^    prst: in std_logic;$/;"	q	component:primitive.DFFE_SR
q	input.vhd	/^    q: out std_logic$/;"	q	component:primitive.DFFE_SR
DLATCHH	input.vhd	/^  component DLATCHH port ($/;"	C	package:primitive
d	input.vhd	/^    d: in std_logic;$/;"	q	component:primitive.DLATCHH
en	input.vhd	/^    en: in std_logic;$/;"	q	component:primitive.DLATCHH
q	input.vhd	/^    q: out std_logic$/;"	q	component:primitive.DLATCHH
AND2	input.vhd	/^  component AND2 port ($/;"	C	package:primitive
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:primitive.AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:primitive.AND2
y	input.vhd	/^    y: out std_logic$/;"	q	component:primitive.AND2
OR2	input.vhd	/^  component OR2 port ($/;"	C	package:primitive
i1	input.vhd	/^    i1: in std_logic;$/;"	q	component:primitive.OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	component:primitive.OR2
y	input.vhd	/^    y: out std_logic$/;"	q	component:primitive.OR2
INVERTER	input.vhd	/^  component INVERTER port ($/;"	C	package:primitive
i	input.vhd	/^    i: in std_logic;$/;"	q	component:primitive.INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	component:primitive.INVERTER
TRIBUF	input.vhd	/^  component TRIBUF port ($/;"	C	package:primitive
ip	input.vhd	/^    ip: in std_logic;$/;"	q	component:primitive.TRIBUF
oe	input.vhd	/^    oe: in std_logic;$/;"	q	component:primitive.TRIBUF
op	input.vhd	/^    op: out std_logic$/;"	q	component:primitive.TRIBUF
BIDIR	input.vhd	/^  component BIDIR port ($/;"	C	package:primitive
ip	input.vhd	/^    ip: in std_logic;$/;"	q	component:primitive.BIDIR
oe	input.vhd	/^    oe: in std_logic;$/;"	q	component:primitive.BIDIR
op_fb	input.vhd	/^    op_fb: out std_logic;$/;"	q	component:primitive.BIDIR
op	input.vhd	/^    op: inout std_logic$/;"	q	component:primitive.BIDIR
DFFE	input.vhd	/^entity DFFE is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFFE
q	input.vhd	/^    q: out std_logic;$/;"	q	entity:DFFE
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFFE
clk	input.vhd	/^    clk: in std_logic$/;"	q	entity:DFFE
rtl	input.vhd	/^architecture rtl of DFFE is$/;"	a	entity:DFFE
anonProcesscfc8de981d0f	input.vhd	/^  process begin$/;"	Q	architecture:DFFE.rtl
DFFE_SR	input.vhd	/^entity DFFE_SR is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DFFE_SR
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DFFE_SR
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFFE_SR
rst	input.vhd	/^    rst: in std_logic;$/;"	q	entity:DFFE_SR
prst	input.vhd	/^    prst: in std_logic;$/;"	q	entity:DFFE_SR
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DFFE_SR
rtl	input.vhd	/^architecture rtl of DFFE_SR is$/;"	a	entity:DFFE_SR
anonProcesscfc8de981e0f	input.vhd	/^  process (clk, rst, prst) begin$/;"	Q	architecture:DFFE_SR.rtl
DLATCHH	input.vhd	/^entity DLATCHH is port ($/;"	e
d	input.vhd	/^    d: in std_logic;$/;"	q	entity:DLATCHH
en	input.vhd	/^    en: in std_logic;$/;"	q	entity:DLATCHH
q	input.vhd	/^    q: out std_logic$/;"	q	entity:DLATCHH
rtl	input.vhd	/^architecture rtl of DLATCHH is$/;"	a	entity:DLATCHH
anonProcesscfc8de981f0f	input.vhd	/^  process (en) begin$/;"	Q	architecture:DLATCHH.rtl
AND2	input.vhd	/^entity AND2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:AND2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:AND2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:AND2
rtl	input.vhd	/^architecture rtl of AND2 is$/;"	a	entity:AND2
OR2	input.vhd	/^entity OR2 is port ($/;"	e
i1	input.vhd	/^    i1: in std_logic;$/;"	q	entity:OR2
i2	input.vhd	/^    i2: in std_logic;$/;"	q	entity:OR2
y	input.vhd	/^    y: out std_logic$/;"	q	entity:OR2
rtl	input.vhd	/^architecture rtl of OR2 is$/;"	a	entity:OR2
INVERTER	input.vhd	/^entity INVERTER is port ($/;"	e
i	input.vhd	/^    i: in std_logic;$/;"	q	entity:INVERTER
o	input.vhd	/^    o: out std_logic$/;"	q	entity:INVERTER
rtl	input.vhd	/^architecture rtl of INVERTER is$/;"	a	entity:INVERTER
TRIBUF	input.vhd	/^entity TRIBUF is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:TRIBUF
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:TRIBUF
op	input.vhd	/^  op: out std_logic$/;"	q	entity:TRIBUF
rtl	input.vhd	/^architecture rtl of TRIBUF is$/;"	a	entity:TRIBUF
BIDIR	input.vhd	/^entity BIDIR is port ($/;"	e
ip	input.vhd	/^  ip: in std_logic;$/;"	q	entity:BIDIR
oe	input.vhd	/^  oe: in std_logic;$/;"	q	entity:BIDIR
op_fb	input.vhd	/^  op_fb: out std_logic;$/;"	q	entity:BIDIR
op	input.vhd	/^  op: inout std_logic$/;"	q	entity:BIDIR
rtl	input.vhd	/^architecture rtl of BIDIR is$/;"	a	entity:BIDIR
progPulse	input.vhd	/^entity progPulse is port ($/;"	e
clk	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
reset	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
loadLength	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
loadDelay	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
data	input.vhd	/^  data: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulse
pulse	input.vhd	/^  pulse: out std_logic$/;"	q	entity:progPulse
rtl	input.vhd	/^architecture rtl of progPulse is$/;"	a	entity:progPulse
downCnt	input.vhd	/^signal downCnt, downCntData: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
downCntData	input.vhd	/^signal downCnt, downCntData: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
downCntLd	input.vhd	/^signal downCntLd, downCntEn: std_logic;$/;"	s	architecture:progPulse.rtl
downCntEn	input.vhd	/^signal downCntLd, downCntEn: std_logic;$/;"	s	architecture:progPulse.rtl
delayCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
pulseCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
startPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
endPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
fsmType	input.vhd	/^subtype fsmType is std_logic_vector(1 downto 0);$/;"	T	architecture:progPulse.rtl
loadDelayCnt	input.vhd	/^constant loadDelayCnt  : fsmType := "00";$/;"	c	architecture:progPulse.rtl
waitDelayEnd	input.vhd	/^constant waitDelayEnd  : fsmType := "10";$/;"	c	architecture:progPulse.rtl
loadLengthCnt	input.vhd	/^constant loadLengthCnt : fsmType := "11";$/;"	c	architecture:progPulse.rtl
waitLengthEnd	input.vhd	/^constant waitLengthEnd : fsmType := "01";$/;"	c	architecture:progPulse.rtl
currState	input.vhd	/^signal currState, nextState: fsmType;$/;"	s	architecture:progPulse.rtl
nextState	input.vhd	/^signal currState, nextState: fsmType;$/;"	s	architecture:progPulse.rtl
delayreg	input.vhd	/^  delayreg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
lengthReg	input.vhd	/^  lengthReg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
nextStProc	input.vhd	/^  nextStProc: process (currState, downCnt, loadDelay, loadLength) begin$/;"	Q	architecture:progPulse.rtl
currStProc	input.vhd	/^  currStProc: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
outConProc	input.vhd	/^  outConProc: process (currState, delayCntVal, pulseCntVal) begin$/;"	Q	architecture:progPulse.rtl
downCntr	input.vhd	/^  downCntr: process (clk,reset) begin$/;"	Q	architecture:progPulse.rtl
pulseErr	input.vhd	/^entity pulseErr is port$/;"	e
a	input.vhd	/^  (a: in std_logic;$/;"	q	entity:pulseErr
b	input.vhd	/^   b: out std_logic$/;"	q	entity:pulseErr
behavior	input.vhd	/^architecture behavior of pulseErr is$/;"	a	entity:pulseErr
c	input.vhd	/^signal c: std_logic;$/;"	s	architecture:pulseErr.behavior
pulse	input.vhd	/^  pulse: process (a,c) begin$/;"	Q	architecture:pulseErr.behavior
progPulse	input.vhd	/^entity progPulse is port ($/;"	e
clk	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
reset	input.vhd	/^  clk, reset: in std_logic;$/;"	q	entity:progPulse
loadLength	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
loadDelay	input.vhd	/^  loadLength,loadDelay: in std_logic;$/;"	q	entity:progPulse
data	input.vhd	/^  data: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulse
pulse	input.vhd	/^  pulse: out std_logic$/;"	q	entity:progPulse
rtl	input.vhd	/^architecture rtl of progPulse is$/;"	a	entity:progPulse
downCnt	input.vhd	/^signal downCnt, downCntData: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
downCntData	input.vhd	/^signal downCnt, downCntData: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
downCntLd	input.vhd	/^signal downCntLd, downCntEn: std_logic;$/;"	s	architecture:progPulse.rtl
downCntEn	input.vhd	/^signal downCntLd, downCntEn: std_logic;$/;"	s	architecture:progPulse.rtl
delayCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
pulseCntVal	input.vhd	/^signal delayCntVal, pulseCntVal: unsigned(7 downto 0);$/;"	s	architecture:progPulse.rtl
startPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
endPulse	input.vhd	/^signal startPulse, endPulse: std_logic;$/;"	s	architecture:progPulse.rtl
progPulseFsmType	input.vhd	/^type progPulseFsmType is (loadDelayCnt, waitDelayEnd, loadLengthCnt, waitLengthEnd);$/;"	t	architecture:progPulse.rtl
currState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulse.rtl
nextState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulse.rtl
delayreg	input.vhd	/^  delayreg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
lengthReg	input.vhd	/^  lengthReg: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
nextStProc	input.vhd	/^  nextStProc: process (currState, downCnt, loadDelay, loadLength) begin$/;"	Q	architecture:progPulse.rtl
currStProc	input.vhd	/^  currStProc: process (clk, reset) begin$/;"	Q	architecture:progPulse.rtl
outConProc	input.vhd	/^  outConProc: process (currState, delayCntVal, pulseCntVal) begin$/;"	Q	architecture:progPulse.rtl
downCntr	input.vhd	/^  downCntr: process (clk,reset) begin$/;"	Q	architecture:progPulse.rtl
progPulseFsm	input.vhd	/^entity progPulseFsm is port ($/;"	e
downCnt	input.vhd	/^  downCnt: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
delayCntVal	input.vhd	/^  delayCntVal: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
lengthCntVal	input.vhd	/^  lengthCntVal: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
loadLength	input.vhd	/^  loadLength: in std_logic;$/;"	q	entity:progPulseFsm
loadDelay	input.vhd	/^  loadDelay: in std_logic;$/;"	q	entity:progPulseFsm
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:progPulseFsm
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:progPulseFsm
downCntEn	input.vhd	/^  downCntEn: out std_logic;$/;"	q	entity:progPulseFsm
downCntLd	input.vhd	/^  downCntLd: out std_logic;$/;"	q	entity:progPulseFsm
downCntData	input.vhd	/^  downCntData: out std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
pulse	input.vhd	/^  pulse: out std_logic$/;"	q	entity:progPulseFsm
fsm	input.vhd	/^architecture fsm of progPulseFsm is$/;"	a	entity:progPulseFsm
progPulseFsmType	input.vhd	/^type progPulseFsmType is (loadDelayCnt, waitDelayEnd, loadLengthCnt, waitLengthEnd);$/;"	t	architecture:progPulseFsm.fsm
stateVec	input.vhd	/^type stateVec is array (3 downto 0) of std_logic;$/;"	t	architecture:progPulseFsm.fsm
stateBits	input.vhd	/^type stateBits is array (progPulseFsmType) of stateVec;$/;"	t	architecture:progPulseFsm.fsm
loadVal	input.vhd	/^signal loadVal: std_logic;$/;"	s	architecture:progPulseFsm.fsm
stateTable	input.vhd	/^constant stateTable: stateBits := ($/;"	c	architecture:progPulseFsm.fsm
currState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulseFsm.fsm
nextState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulseFsm.fsm
nextStProc	input.vhd	/^  nextStProc: process (currState, downCnt, loadDelay, loadLength) begin$/;"	Q	architecture:progPulseFsm.fsm
currStProc	input.vhd	/^  currStProc: process (clk, reset) begin$/;"	Q	architecture:progPulseFsm.fsm
progPulseFsm	input.vhd	/^entity progPulseFsm is port ($/;"	e
downCnt	input.vhd	/^  downCnt: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
delayCntVal	input.vhd	/^  delayCntVal: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
lengthCntVal	input.vhd	/^  lengthCntVal: in std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
loadLength	input.vhd	/^  loadLength: in std_logic;$/;"	q	entity:progPulseFsm
loadDelay	input.vhd	/^  loadDelay: in std_logic;$/;"	q	entity:progPulseFsm
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:progPulseFsm
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:progPulseFsm
downCntEn	input.vhd	/^  downCntEn: out std_logic;$/;"	q	entity:progPulseFsm
downCntLd	input.vhd	/^  downCntLd: out std_logic;$/;"	q	entity:progPulseFsm
downtCntData	input.vhd	/^  downtCntData: out std_logic_vector(7 downto 0);$/;"	q	entity:progPulseFsm
pulse	input.vhd	/^  pulse: out std_logic$/;"	q	entity:progPulseFsm
fsm	input.vhd	/^architecture fsm of progPulseFsm is$/;"	a	entity:progPulseFsm
progPulseFsmType	input.vhd	/^type progPulseFsmType is (loadDelayCnt, waitDelayEnd, loadLengthCnt, waitLengthEnd);$/;"	t	architecture:progPulseFsm.fsm
currState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulseFsm.fsm
nextState	input.vhd	/^signal currState, nextState: progPulseFsmType;$/;"	s	architecture:progPulseFsm.fsm
downCntL	input.vhd	/^signal downCntL: unsigned (7 downto 0);$/;"	s	architecture:progPulseFsm.fsm
nextStProc	input.vhd	/^  nextStProc: process (currState, downCntL, loadDelay, loadLength) begin$/;"	Q	architecture:progPulseFsm.fsm
currStProc	input.vhd	/^  currStProc: process (clk, reset) begin$/;"	Q	architecture:progPulseFsm.fsm
outConProc	input.vhd	/^  outConProc: process (currState, delayCntVal, lengthCntVal) begin$/;"	Q	architecture:progPulseFsm.fsm
powerOfFour	input.vhd	/^entity powerOfFour is port($/;"	e
clk	input.vhd	/^  clk      : in  std_logic; $/;"	q	entity:powerOfFour
inputVal	input.vhd	/^  inputVal : in  std_logic_vector(3 downto 0);$/;"	q	entity:powerOfFour
power	input.vhd	/^  power    : out std_logic_vector(15 downto 0)$/;"	q	entity:powerOfFour
behavioral	input.vhd	/^architecture behavioral of powerOfFour is$/;"	a	entity:powerOfFour
anonProcesscfc8de98200f	input.vhd	/^   process begin$/;"	Q	architecture:powerOfFour.behavioral
powerOfFour	input.vhd	/^entity powerOfFour is port($/;"	e
clk	input.vhd	/^  clk      : in  std_logic; $/;"	q	entity:powerOfFour
inputVal	input.vhd	/^  inputVal : in  std_logic_vector(3 downto 0);$/;"	q	entity:powerOfFour
power	input.vhd	/^  power    : out std_logic_vector(15 downto 0)$/;"	q	entity:powerOfFour
behavioral	input.vhd	/^architecture behavioral of powerOfFour is$/;"	a	entity:powerOfFour
Pow	input.vhd	/^   function Pow( N, Exp : integer )  return integer is$/;"	f	architecture:powerOfFour.behavioral
Result	input.vhd	/^      Variable Result   : integer := 1;$/;"	v	function:powerOfFour.behavioral.Pow
anonProcesscfc8de98210f	input.vhd	/^   process begin$/;"	Q	architecture:powerOfFour.behavioral
powerOfFour	input.vhd	/^entity powerOfFour is port($/;"	e
clk	input.vhd	/^  clk      : in  std_logic; $/;"	q	entity:powerOfFour
inputVal	input.vhd	/^  inputVal : in  std_logic_vector(3 downto 0);$/;"	q	entity:powerOfFour
power	input.vhd	/^  power    : out std_logic_vector(15 downto 0)$/;"	q	entity:powerOfFour
behavioral	input.vhd	/^architecture behavioral of powerOfFour is$/;"	a	entity:powerOfFour
Pow	input.vhd	/^   function Pow( N, Exp : integer )  return integer is$/;"	f	architecture:powerOfFour.behavioral
Result	input.vhd	/^      Variable Result   : integer := 1;$/;"	v	function:powerOfFour.behavioral.Pow
anonProcesscfc8de98220f	input.vhd	/^   process begin$/;"	Q	architecture:powerOfFour.behavioral
regFile	input.vhd	/^entity regFile is port ($/;"	e
clk	input.vhd	/^  clk, rst: in std_logic;$/;"	q	entity:regFile
rst	input.vhd	/^  clk, rst: in std_logic;$/;"	q	entity:regFile
data	input.vhd	/^  data: in std_logic_vector(31 downto 0);$/;"	q	entity:regFile
regSel	input.vhd	/^  regSel: in std_logic_vector(1 downto 0);$/;"	q	entity:regFile
wrEnable	input.vhd	/^  wrEnable: in std_logic;$/;"	q	entity:regFile
regOut	input.vhd	/^  regOut: out std_logic_vector(31 downto 0)$/;"	q	entity:regFile
behavioral	input.vhd	/^architecture behavioral of regFile is$/;"	a	entity:regFile
reg	input.vhd	/^subtype reg is std_logic_vector(31 downto 0);$/;"	T	architecture:regFile.behavioral
regArray	input.vhd	/^type regArray is array (integer range <>) of reg;$/;"	t	architecture:regFile.behavioral
registerFile	input.vhd	/^signal registerFile: regArray(0 to 3);$/;"	s	architecture:regFile.behavioral
regProc	input.vhd	/^  regProc: process (clk, rst) $/;"	Q	architecture:regFile.behavioral
i	input.vhd	/^  variable i: integer;$/;"	v	process:regFile.behavioral.regProc
outputs	input.vhd	/^  outputs: process(regSel, registerFile) begin$/;"	Q	architecture:regFile.behavioral
DFF	input.vhd	/^entity DFF is port ($/;"	e
d1	input.vhd	/^    d1,d2: in std_logic;$/;"	q	entity:DFF
d2	input.vhd	/^    d1,d2: in std_logic;$/;"	q	entity:DFF
q1	input.vhd	/^    q1,q2: out std_logic;$/;"	q	entity:DFF
q2	input.vhd	/^    q1,q2: out std_logic;$/;"	q	entity:DFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:DFF
rst	input.vhd	/^    rst : in std_logic$/;"	q	entity:DFF
rtl	input.vhd	/^architecture rtl of DFF is$/;"	a	entity:DFF
resetLatch	input.vhd	/^  resetLatch: process (clk, rst) begin$/;"	Q	architecture:DFF.rtl
resFcnDemo	input.vhd	/^entity resFcnDemo is port ($/;"	e
a	input.vhd	/^  a, b: in std_logic;$/;"	q	entity:resFcnDemo
b	input.vhd	/^  a, b: in std_logic;$/;"	q	entity:resFcnDemo
oeA	input.vhd	/^  oeA,oeB: in std_logic;$/;"	q	entity:resFcnDemo
oeB	input.vhd	/^  oeA,oeB: in std_logic;$/;"	q	entity:resFcnDemo
result	input.vhd	/^  result: out std_logic$/;"	q	entity:resFcnDemo
multiDriver	input.vhd	/^architecture multiDriver of resFcnDemo is$/;"	a	entity:resFcnDemo
scaleDFF	input.vhd	/^entity scaleDFF is port ($/;"	e
data	input.vhd	/^  data: in std_logic_vector(7 downto 0);$/;"	q	entity:scaleDFF
clock	input.vhd	/^  clock: in std_logic;$/;"	q	entity:scaleDFF
enable	input.vhd	/^  enable: in std_logic;$/;"	q	entity:scaleDFF
qout	input.vhd	/^  qout: out std_logic_vector(7 downto 0)$/;"	q	entity:scaleDFF
scalable	input.vhd	/^architecture scalable of scaleDFF is$/;"	a	entity:scaleDFF
sevenSegment	input.vhd	/^entity sevenSegment is port ($/;"	e
bcdInputs	input.vhd	/^  bcdInputs: in std_logic_vector (3 downto 0);$/;"	q	entity:sevenSegment
a_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
b_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
c_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
d_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
e_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
f_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
g_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
behavioral	input.vhd	/^architecture behavioral of sevenSegment is$/;"	a	entity:sevenSegment
la_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
lb_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
lc_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
ld_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
le_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
lf_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
lg_n	input.vhd	/^signal la_n, lb_n, lc_n, ld_n, le_n, lf_n, lg_n: std_logic;$/;"	s	architecture:sevenSegment.behavioral
oe	input.vhd	/^signal oe: std_logic;$/;"	s	architecture:sevenSegment.behavioral
bcd2sevSeg	input.vhd	/^  bcd2sevSeg: process (bcdInputs) begin$/;"	Q	architecture:sevenSegment.behavioral
sevenSegmentTB	input.vhd	/^entity sevenSegmentTB is$/;"	e
testbench	input.vhd	/^architecture testbench of sevenSegmentTB is$/;"	a	entity:sevenSegmentTB
sevenSegment	input.vhd	/^component sevenSegment port ($/;"	C	architecture:sevenSegmentTB.testbench
bcdInputs	input.vhd	/^  bcdInputs: in std_logic_vector (3 downto 0);$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
a_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
b_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
c_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
d_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
e_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
f_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
g_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	component:sevenSegmentTB.testbench.sevenSegment
vector	input.vhd	/^type vector is record$/;"	t	architecture:sevenSegmentTB.testbench
bcdStimulus	input.vhd	/^  bcdStimulus: std_logic_vector(3 downto 0);$/;"	r	type:sevenSegmentTB.testbench.vector
sevSegOut	input.vhd	/^  sevSegOut: std_logic_vector(6 downto 0);$/;"	r	type:sevenSegmentTB.testbench.vector
NumVectors	input.vhd	/^constant NumVectors: integer:= 17;$/;"	c	architecture:sevenSegmentTB.testbench
PropDelay	input.vhd	/^constant PropDelay: time := 40 ns;$/;"	c	architecture:sevenSegmentTB.testbench
SimLoopDelay	input.vhd	/^constant SimLoopDelay: time := 10 ns;$/;"	c	architecture:sevenSegmentTB.testbench
vectorArray	input.vhd	/^type vectorArray is array (0 to NumVectors - 1) of vector;$/;"	t	architecture:sevenSegmentTB.testbench
vectorTable	input.vhd	/^constant vectorTable: vectorArray := ($/;"	c	architecture:sevenSegmentTB.testbench
StimInputs	input.vhd	/^signal StimInputs: std_logic_vector(3 downto 0);$/;"	s	architecture:sevenSegmentTB.testbench
CaptureOutputs	input.vhd	/^signal CaptureOutputs: std_logic_vector(6 downto 0);$/;"	s	architecture:sevenSegmentTB.testbench
LoopStim	input.vhd	/^  LoopStim: process$/;"	Q	architecture:sevenSegmentTB.testbench
FoundError	input.vhd	/^    variable FoundError: boolean := false;$/;"	v	process:sevenSegmentTB.testbench.LoopStim
TempVector	input.vhd	/^    variable TempVector: vector;$/;"	v	process:sevenSegmentTB.testbench.LoopStim
ErrorMsgLine	input.vhd	/^    variable ErrorMsgLine: line;$/;"	v	process:sevenSegmentTB.testbench.LoopStim
sevenSegment	input.vhd	/^entity sevenSegment is port ($/;"	e
bcdInputs	input.vhd	/^  bcdInputs: in std_logic_vector (3 downto 0);$/;"	q	entity:sevenSegment
a_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
b_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
c_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
d_n	input.vhd	/^  a_n, b_n, c_n, d_n,$/;"	q	entity:sevenSegment
e_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
f_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
g_n	input.vhd	/^  e_n, f_n, g_n: out std_logic$/;"	q	entity:sevenSegment
behavioral	input.vhd	/^architecture behavioral of sevenSegment is$/;"	a	entity:sevenSegment
bcd2sevSeg	input.vhd	/^  bcd2sevSeg: process (bcdInputs) begin$/;"	Q	architecture:sevenSegment.behavioral
ForceShare	input.vhd	/^entity ForceShare is port ($/;"	e
a	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
b	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
c	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
d	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
e	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
f	input.vhd	/^  a,b,c,d,e,f: in std_logic_vector (7 downto 0);$/;"	q	entity:ForceShare
result	input.vhd	/^  result: out std_logic_vector(7 downto 0)$/;"	q	entity:ForceShare
behaviour	input.vhd	/^architecture behaviour of ForceShare is$/;"	a	entity:ForceShare
sum	input.vhd	/^  sum: process (a,c,b,d,e,f)$/;"	Q	architecture:ForceShare.behaviour
tempSum	input.vhd	/^  variable tempSum: std_logic_vector(7 downto 0);$/;"	v	process:ForceShare.behaviour.sum
shifter	input.vhd	/^entity shifter is port ($/;"	e
clk	input.vhd	/^  clk, rst: in std_logic;$/;"	q	entity:shifter
rst	input.vhd	/^  clk, rst: in std_logic;$/;"	q	entity:shifter
shiftEn	input.vhd	/^  shiftEn,shiftIn: std_logic;$/;"	q	entity:shifter
shiftIn	input.vhd	/^  shiftEn,shiftIn: std_logic;$/;"	q	entity:shifter
q	input.vhd	/^  q: out std_logic_vector (15 downto 0)$/;"	q	entity:shifter
behav	input.vhd	/^architecture behav of shifter is$/;"	a	entity:shifter
qLocal	input.vhd	/^signal qLocal: std_logic_vector(15 downto 0);$/;"	s	architecture:shifter.behav
shift	input.vhd	/^  shift: process (clk, rst) begin$/;"	Q	architecture:shifter.behav
lastAssignment	input.vhd	/^entity lastAssignment is port$/;"	e
a	input.vhd	/^  (a, b: in std_logic;$/;"	q	entity:lastAssignment
b	input.vhd	/^  (a, b: in std_logic;$/;"	q	entity:lastAssignment
selA	input.vhd	/^   selA, selb: in std_logic;$/;"	q	entity:lastAssignment
selb	input.vhd	/^   selA, selb: in std_logic;$/;"	q	entity:lastAssignment
result	input.vhd	/^   result: out std_logic$/;"	q	entity:lastAssignment
behavioral	input.vhd	/^architecture behavioral of lastAssignment is$/;"	a	entity:lastAssignment
demo	input.vhd	/^  demo: process (a,b,selA,selB) begin$/;"	Q	architecture:lastAssignment.behavioral
signalDemo	input.vhd	/^entity signalDemo is port ($/;"	e
a	input.vhd	/^  a: in std_logic;$/;"	q	entity:signalDemo
b	input.vhd	/^  b: out std_logic$/;"	q	entity:signalDemo
basic	input.vhd	/^architecture basic of signalDemo is$/;"	a	entity:signalDemo
c	input.vhd	/^signal c: std_logic;$/;"	s	architecture:signalDemo.basic
demo	input.vhd	/^  demo: process (a) begin$/;"	Q	architecture:signalDemo.basic
signalDemo	input.vhd	/^entity signalDemo is port ($/;"	e
a	input.vhd	/^  a: in std_logic;$/;"	q	entity:signalDemo
b	input.vhd	/^  b: out std_logic$/;"	q	entity:signalDemo
basic	input.vhd	/^architecture basic of signalDemo is$/;"	a	entity:signalDemo
c	input.vhd	/^signal c: std_logic;$/;"	s	architecture:signalDemo.basic
demo	input.vhd	/^  demo: process (a) begin$/;"	Q	architecture:signalDemo.basic
simPrimitives	input.vhd	/^package simPrimitives is$/;"	P
OR2	input.vhd	/^  component OR2$/;"	C	package:simPrimitives
tPD	input.vhd	/^    generic (tPD: time := 1 ns);$/;"	g	component:simPrimitives.OR2
I1	input.vhd	/^    port (I1, I2: in std_logic;$/;"	q	component:simPrimitives.OR2
I2	input.vhd	/^    port (I1, I2: in std_logic;$/;"	q	component:simPrimitives.OR2
Y	input.vhd	/^          Y: out std_logic$/;"	q	component:simPrimitives.OR2
SimDFF	input.vhd	/^  component SimDFF$/;"	C	package:simPrimitives
tCQ	input.vhd	/^  generic(tCQ: time := 1 ns;$/;"	g	component:simPrimitives.SimDFF
tS	input.vhd	/^          tS : time := 1 ns;$/;"	g	component:simPrimitives.SimDFF
tH	input.vhd	/^          tH : time := 1 ns$/;"	g	component:simPrimitives.SimDFF
D	input.vhd	/^  port (D, Clk: in std_logic;$/;"	q	component:simPrimitives.SimDFF
Clk	input.vhd	/^  port (D, Clk: in std_logic;$/;"	q	component:simPrimitives.SimDFF
Q	input.vhd	/^        Q: out std_logic$/;"	q	component:simPrimitives.SimDFF
OR2	input.vhd	/^entity OR2 is$/;"	e
tPD	input.vhd	/^  generic (tPD: time := 1 ns);$/;"	g	entity:OR2
I1	input.vhd	/^  port (I1, I2: in std_logic;$/;"	q	entity:OR2
I2	input.vhd	/^  port (I1, I2: in std_logic;$/;"	q	entity:OR2
Y	input.vhd	/^    Y: out std_logic$/;"	q	entity:OR2
simple	input.vhd	/^architecture simple of OR2 is$/;"	a	entity:OR2
SimDFF	input.vhd	/^entity SimDFF is$/;"	e
tCQ	input.vhd	/^  generic(tCQ: time := 1 ns;$/;"	g	entity:SimDFF
tS	input.vhd	/^          tS : time := 1 ns;$/;"	g	entity:SimDFF
tH	input.vhd	/^          tH : time := 1 ns$/;"	g	entity:SimDFF
D	input.vhd	/^  port (D, Clk: in std_logic;$/;"	q	entity:SimDFF
Clk	input.vhd	/^  port (D, Clk: in std_logic;$/;"	q	entity:SimDFF
Q	input.vhd	/^  Q: out std_logic$/;"	q	entity:SimDFF
SimModel	input.vhd	/^architecture SimModel of SimDFF is$/;"	a	entity:SimDFF
reg	input.vhd	/^  reg: process (Clk, D) begin$/;"	Q	architecture:SimDFF.SimModel
SRFF	input.vhd	/^entity SRFF is port ($/;"	e
s	input.vhd	/^    s,r: in std_logic;$/;"	q	entity:SRFF
r	input.vhd	/^    s,r: in std_logic;$/;"	q	entity:SRFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:SRFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:SRFF
rtl	input.vhd	/^architecture rtl of SRFF is$/;"	a	entity:SRFF
anonProcesscfc8de98230f	input.vhd	/^  process begin$/;"	Q	architecture:SRFF.rtl
SRFF	input.vhd	/^entity SRFF is port ($/;"	e
s	input.vhd	/^    s,r: in std_logic;$/;"	q	entity:SRFF
r	input.vhd	/^    s,r: in std_logic;$/;"	q	entity:SRFF
clk	input.vhd	/^    clk: in std_logic;$/;"	q	entity:SRFF
q	input.vhd	/^    q: out std_logic$/;"	q	entity:SRFF
rtl	input.vhd	/^architecture rtl of SRFF is$/;"	a	entity:SRFF
anonProcesscfc8de98240f	input.vhd	/^  process begin$/;"	Q	architecture:SRFF.rtl
scaleable	input.vhd	/^package scaleable is$/;"	P
scaleUpCnt	input.vhd	/^  component scaleUpCnt port ($/;"	C	package:scaleable
clk	input.vhd	/^    clk: in std_logic;$/;"	q	component:scaleable.scaleUpCnt
reset	input.vhd	/^    reset: in std_logic;$/;"	q	component:scaleable.scaleUpCnt
cnt	input.vhd	/^    cnt: in std_logic_vector$/;"	q	component:scaleable.scaleUpCnt
scaleUpCnt	input.vhd	/^entity scaleUpCnt is port ($/;"	e
clk	input.vhd	/^  clk: in std_logic;$/;"	q	entity:scaleUpCnt
reset	input.vhd	/^  reset: in std_logic;$/;"	q	entity:scaleUpCnt
cnt	input.vhd	/^  cnt: out std_logic_vector$/;"	q	entity:scaleUpCnt
scaleable	input.vhd	/^architecture scaleable of scaleUpCnt is$/;"	a	entity:scaleUpCnt
one	input.vhd	/^signal one: std_logic := '1';$/;"	s	architecture:scaleUpCnt.scaleable
cntL	input.vhd	/^signal cntL: std_logic_vector(cnt'range);$/;"	s	architecture:scaleUpCnt.scaleable
andTerm	input.vhd	/^signal andTerm: std_logic_vector(cnt'range);$/;"	s	architecture:scaleUpCnt.scaleable
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 		targetFsmType := "101";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "010";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 		targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "110";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 		targetFsmType := "001";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 		targetFsmType := "010";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "110";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 	targetFsmType := "001";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "010";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 	targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "100";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(3 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "0000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 	targetFsmType := "0001";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "0011";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 	targetFsmType := "1100";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "1101";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 		targetFsmType := "101";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "010";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 		targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "110";$/;"	c	architecture:pci_target.fsm
Dont_Care	input.vhd	/^constant Dont_Care: targetFsmType := "XXX";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;    -- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;     -- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;            -- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;         -- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;           -- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;          -- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;      -- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;       -- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;        -- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;        -- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;    -- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;    -- PCI Stop#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;    -- PCI Trdy#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;         -- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;     -- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;     -- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic    -- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^type targetFsmType is (Idle, B_Busy, Backoff, S_Data, Turn_Ar);$/;"	t	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;    -- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;     -- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;            -- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;         -- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;           -- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;          -- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;      -- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;       -- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;        -- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;        -- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;    -- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;  -- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;    -- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;    -- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;         -- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;     -- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;     -- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic    -- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(4 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle:    integer := 0;$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy:  integer := 1;$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: integer := 2;$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data:  integer := 3;$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: integer := 4;$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;	-- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;		-- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;			-- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;			-- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;			-- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;			-- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;		-- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;		-- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;		-- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;		-- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;	-- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;	-- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;	-- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;	-- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;			-- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;		-- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;		-- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic	-- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^constant Idle: 		targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^constant B_Busy: 	targetFsmType := "001";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^constant Backoff: 	targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^constant S_Data: 	targetFsmType := "110";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^constant Turn_Ar: 	targetFsmType := "100";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
pci_target	input.vhd	/^entity pci_target is port ($/;"	e
PCI_Frame_n	input.vhd	/^  PCI_Frame_n: in std_logic;    -- PCI Frame#$/;"	q	entity:pci_target
PCI_Irdy_n	input.vhd	/^  PCI_Irdy_n: in std_logic;     -- PCI Irdy#$/;"	q	entity:pci_target
Hit	input.vhd	/^  Hit: in std_logic;            -- Hit on address decode$/;"	q	entity:pci_target
D_Done	input.vhd	/^  D_Done: in std_logic;         -- Device decode complete$/;"	q	entity:pci_target
Term	input.vhd	/^  Term: in std_logic;           -- Terminate transaction$/;"	q	entity:pci_target
Ready	input.vhd	/^  Ready: in std_logic;          -- Ready to transfer data$/;"	q	entity:pci_target
Cmd_Write	input.vhd	/^  Cmd_Write: in std_logic;      -- Command is Write$/;"	q	entity:pci_target
Cmd_Read	input.vhd	/^  Cmd_Read: in std_logic;       -- Command is Read$/;"	q	entity:pci_target
T_Abort	input.vhd	/^  T_Abort: in std_logic;        -- Target error  - abort transaction$/;"	q	entity:pci_target
PCI_Clk	input.vhd	/^  PCI_Clk: in std_logic;        -- PCI Clock$/;"	q	entity:pci_target
PCI_Reset_n	input.vhd	/^  PCI_Reset_n: in std_logic;    -- PCI Reset#$/;"	q	entity:pci_target
PCI_Devsel_n	input.vhd	/^  PCI_Devsel_n: out std_logic;  -- PCI Devsel#$/;"	q	entity:pci_target
PCI_Trdy_n	input.vhd	/^  PCI_Trdy_n: out std_logic;    -- PCI Trdy#$/;"	q	entity:pci_target
PCI_Stop_n	input.vhd	/^  PCI_Stop_n: out std_logic;    -- PCI Stop#$/;"	q	entity:pci_target
OE_AD	input.vhd	/^  OE_AD: out std_logic;         -- PCI AD bus enable$/;"	q	entity:pci_target
OE_Trdy_n	input.vhd	/^  OE_Trdy_n: out std_logic;     -- PCI Trdy# enable$/;"	q	entity:pci_target
OE_Stop_n	input.vhd	/^  OE_Stop_n: out std_logic;     -- PCI Stop# enable$/;"	q	entity:pci_target
OE_Devsel_n	input.vhd	/^  OE_Devsel_n: out std_logic    -- PCI Devsel# enable$/;"	q	entity:pci_target
fsm	input.vhd	/^architecture fsm of pci_target is$/;"	a	entity:pci_target
LPCI_Devsel_n	input.vhd	/^  signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Trdy_n	input.vhd	/^  signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
LPCI_Stop_n	input.vhd	/^  signal LPCI_Devsel_n, LPCI_Trdy_n, LPCI_Stop_n: std_logic;$/;"	s	architecture:pci_target.fsm
targetFsmType	input.vhd	/^  subtype targetFsmType is std_logic_vector(2 downto 0);$/;"	T	architecture:pci_target.fsm
Idle	input.vhd	/^  constant Idle:    targetFsmType := "000";$/;"	c	architecture:pci_target.fsm
B_Busy	input.vhd	/^  constant B_Busy:  targetFsmType := "001";$/;"	c	architecture:pci_target.fsm
Backoff	input.vhd	/^  constant Backoff: targetFsmType := "011";$/;"	c	architecture:pci_target.fsm
S_Data	input.vhd	/^  constant S_Data:  targetFsmType := "110";$/;"	c	architecture:pci_target.fsm
Turn_Ar	input.vhd	/^  constant Turn_Ar: targetFsmType := "100";$/;"	c	architecture:pci_target.fsm
currState	input.vhd	/^  signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nextState	input.vhd	/^  signal currState, nextState: targetFsmType;$/;"	s	architecture:pci_target.fsm
nxtStProc	input.vhd	/^ nxtStProc: process (currState, PCI_Frame_n, Hit, D_Done, PCI_Irdy_n, LPCI_Trdy_n,$/;"	Q	architecture:pci_target.fsm
curStProc	input.vhd	/^  curStProc: process (PCI_Clk, PCI_Reset_n) begin$/;"	Q	architecture:pci_target.fsm
outConProc	input.vhd	/^  outConProc: process (currState, Ready, T_Abort, Cmd_Write,$/;"	Q	architecture:pci_target.fsm
test	input.vhd	/^entity test is port ($/;"	e
a	input.vhd	/^  a: in std_logic;$/;"	q	entity:test
z	input.vhd	/^  z: out std_logic;$/;"	q	entity:test
en	input.vhd	/^  en: in std_logic$/;"	q	entity:test
simple	input.vhd	/^architecture simple of test is$/;"	a	entity:test
